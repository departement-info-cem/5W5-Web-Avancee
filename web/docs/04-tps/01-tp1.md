import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# TP1 (Super Cartes Infinies)

## Le projet

DÃ©velopper un jeu de cartes (avec un style similaire Ã  Hearthstone).
Le projet se fait en Ã©quipe de 3 ou 4.

<!-- ğŸš§ Les dÃ©tails du TP1 seront dÃ©voilÃ©s plus tard -->

## Ã‰valuations

- Diagramme de classes (Remise Ã  la **Rencontre 7**)
- Ã‰valuation **individuelle** (Ã‰valuation Ã  la **Rencontre 10**, sauf tÃ¢che **Hub** Ã  la **Rencontre 11**)
- Ã‰valuation de **groupe** (Ã‰valuation Ã  la **Rencontre 13**)

## L'application

### Objectifs :

- Analyser un problÃ¨me et le dÃ©couper en Epics, User Stories et Tasks Ã  l'aide d'Azure DevOps Boards.
- CrÃ©er un diagramme de classes de la solution.
- ComplÃ©ter un application web Ã  lâ€™aide dâ€™Angular, Web API et MVC pour faire un jeu de cartes de style HearthStone.
- Le site Angular sera utilisÃ© par des membres inscrits en utilisant des tokens pour l'authentification.
- Lâ€™administrateur pourra configurer le contenu de lâ€™application Ã  lâ€™aide de MVC.
- Il n'est pas nÃ©cessaire d'Ã©crire des tests pour le premier TP, mais nous allons en Ã©crire pour les 2 prochains.

### Les rÃ¨gles :

- Deux joueurs sâ€™affrontent avec leurs cartes.
- Chaque joueur pige un nombre de cartes configurable dÃ¨s le dÃ©part.
- Chaque joueur pige une carte au dÃ©but de son tour.
- Chaque joueur reÃ§oit une quantitÃ© configurable de mana au dÃ©but de son tour.
- Chaque carte a une certaine quantitÃ© de points dâ€™attaque, une certaine quantitÃ© de points de dÃ©fense et un coÃ»t en mana.
- Les joueurs ne pourront **pas encore jouer de carte** avant le TP2. Nous allons voir les rÃ¨gles du jeu plus en dÃ©tail Ã  ce moment.
- Un joueur peut terminer son tour. Le tour de lâ€™autre joueur commence alors et il reÃ§oit sa carte et son mana.
- Un joueur peut abandonner la partie et il perd alors automatiquement (lâ€™autre joueur a une victoire).

### Clarification :

Le mot Â« carte Â» est utilisÃ© trÃ¨s frÃ©quemment, mais il faut comprendre que lâ€™on ne parle pas toujours du modÃ¨le de donnÃ©e (Card). En effet, lorsquâ€™on configure le jeu, le mot carte fait rÃ©fÃ©rence au Â« modÃ¨le Â» de la carte. Mais si on mentionne quâ€™un joueur possÃ¨de des cartes, on a besoin dâ€™un modÃ¨le qui permet dâ€™associer une carte Ã  un joueur. Le premier livrable du projet est un diagramme de classe qui va permettre de clarifier tout Ã§a.

### Contraintes

- Le travail doit Ãªtre effectuÃ© en Ã©quipes de 3 ou 4.
- Vous devrez utiliser Git/GitHub.
- Vous devrez utiliser Azure DevOps pour la gestion des tÃ¢ches.
- Vous devrez complÃ©ter une application cliente en Angular.
- Vous devrez complÃ©ter une application serveur en ASP.NET MVC et WebAPI.

## Livraisons du TP

### MatÃ©riel de dÃ©part

Voici le diagramme de classe Ã  complÃ©ter. Vous devrez complÃ©ter le diagramme dans le `README.md` du repo de votre projet .NET. Vous pouvez consulter la documentation de Mermaid si vous le dÃ©sirez : [Diagrammes Mermaid](https://mermaid.js.org/syntax/classDiagram.html).

<!-- Attention, si on modifie le diagramme ici, il faut aussi le modifier sur le projet de dÃ©part .NET  -->
```mermaid
classDiagram
    direction RL
    Player "0..1" -- "1..1" IdentityUser
    MatchPlayerData "0..n" -- "1..1" Player
    Match "1..1" -- "2..2" MatchPlayerData
    PlayableCard "0..n" -- "1..1" MatchPlayerData : Hand/CardsPile/Graveyard/BattleField
    Card "0..n"  -- "1..1" PlayableCard

    class IdentityUser{
      string Id
      Reste des champs...
    }

    class Player{
      int Id
      string Name
      string Profile
      &lt;FK&gt;string UserId
    }

    class Match{
      int Id
      bool IsPlayerATurn
      bool IsMatchCompleted
      string WinnerUserId
      string UserAId
      string UserBId
      &lt;FK&gt;int PlayerDataAId
      &lt;FK&gt;int PlayerDataBId
    }

    class MatchPlayerData{
      int Id
      int Health
      int Mana
      &lt;FK&gt;int PlayerId
    }

    class PlayableCard{
      int Id
      int Health
      int Mana
      &lt;FK&gt;int CardId
      &lt;FK&gt;int MatchPlayerDataId
      &lt;FK&gt;int MatchPlayerDataId1
      &lt;FK&gt;int MatchPlayerDataId2
      &lt;FK&gt;int MatchPlayerDataId3
    }

    class Card{
      int Id
      string Name
      int Attack
      int Health
      int Cost
      string ImageURL
    }

```

Pour le client et le serveur:

- Votre enseignant aura crÃ©Ã© les repos nÃ©cessaires au projet Ã  l'aide de Github Classroom.
  - Assurez vous que chaque membre de l'Ã©quipe y a accÃ¨s.

<!-- C'est maintenant dÃ©jÃ  fourni avec Github Classroom
- Ajouter ensuite tÃ©lÃ©chargez un zip de chacun de ces projets, ajouter le contenu des zips extraits Ã  chacuns des repos respectifs, et faire un commit/push. Voici les repos de dÃ©part:
  - ğŸ”—[Client de dÃ©part](https://github.com/CEM-420-5W5/ngsci-depart)
  - ğŸ”—[Serveur de dÃ©part](https://github.com/CEM-420-5W5/sci-depart)
-->

- CrÃ©er les branches suivantes
  - Serveur:
    - MVC
    - Authentification
    - SignalR
  - Client:
    - Angular
    - Authentification
    - SignalR

:::info
Chaque Ã©tudiant doit travailler dans la **bonne branche pour son travail**. Une fois que les parties individuelles seront terminÃ©es, vous allez pouvoir tout ramener vers la mÃªme branche. Nous allons voir comment bien le faire en classe!
:::

### Les Ã©tapes

Il y a 3 Ã©tapes de livraison du premier TP :

- Diagramme de classe et Azure DevOps (Ã©valuation de groupe)
- FonctionnalitÃ©s (Ã©valuation individuelle)
- IntÃ©gration des fonctionnalitÃ©s, DevOps et Git (Ã©valuation de groupe)

## Le dÃ©tail des tÃ¢ches individuelles

<details>
<summary>Section dâ€™administration (MVC)</summary>
- Lâ€™administrateur peut crÃ©er, modifier, voir et supprimer les **cartes modÃ¨les** (CRUD).
- Cartes de dÃ©part:
  - Mettre en place le modÃ¨le de donnÃ©es des cartes de dÃ©part.
  - Lâ€™administrateur peut modifier les cartes de dÃ©part des nouveaux joueurs. **Faire un tri par le nom de la carte dans lâ€™Index.**
  - Ajouter un seed des cartes de dÃ©part. Il doit contenir 3 cartes diffÃ©rentes avec une seule copie et 3 autres cartes avec deux copies chaque.
  - Il existe un **STUB** de StartingCardsService pour les cartes de dÃ©part. Il faut retourner les cartes configurÃ©es Ã  l'aide des cartes de dÃ©part.
- Configuration:

  - Mettre en place le modÃ¨le de donnÃ©es de la configuration (**GameConfig**).
  - Ajouter une page de configuration pour lâ€™administrateur. Permettre dâ€™avoir une configuration pour le **nombre de cartes Ã  piger** avant de commencer la partie (nbCardsToDraw) et la **quantitÃ© de Mana reÃ§u au dÃ©but de chaque tour**.
  - Ajouter un seed pour la configuration avec une quantitÃ© de 4 cartes Ã  piger et 3 manas par tour.

  :::warning
  Ce nâ€™est pas un problÃ¨me que la configuration soit une table avec une seule entrÃ©e. Dans une version plus avancÃ©e du projet, on pourrait imaginer quâ€™il y ait plusieurs modes de jeu diffÃ©rents avec des configurations diffÃ©rentes. Vous pouvez faire simplement utiliser First() sur le DbSet.
  :::

  - Il existe un **STUB** du MatchConfigurationService qui retourne le nombre de cartes reÃ§u au dÃ©but de la partie et le nombre de mana reÃ§u par tour. Il faut retourner les valeurs de la configuration.

- Ajoutez un lien sur la page home vers les pages suivantes: "Cartes", "Cartes de dÃ©part" et "Configuration"
- ProtÃ©gez TOUT les contrÃ´leurs (sauf Home) pour que le rÃ´le admin soit nÃ©cessaire.
- Vous pouvez simplement retirer les pages dÃ©tails de vos contrÃ´leurs/vues

:::warning
Le site doit Ãªtre dÃ©veloppÃ© en **franÃ§ais**, **MAIS** ce n'est **pas** nÃ©cessaire de traduire tout ce qui est reliÃ© Ã  l'authentification avec **Identity**. Donc simplement utiliser le franÃ§ais pour le contenu que vous ajoutez (Ce qui inclus d'utiliser des DisplayName pour afficher les mots en franÃ§ais).
:::

</details>

<details>
<summary>Enregistrement et connexion (Authentification)</summary>

.NET:

- Mettre en place le modÃ¨le de donnÃ©es **OwnedCard** pour permettre aux players d'avoir ses propres cartes.
- Ajouter un contrÃ´leur d'API pour gÃ©rer l'enregistrement et la connexion.
- Lors de l'enregistrement, il faut appeler la mÃ©thode CreatePlayer de PlayersService.
- Il faut terminer l'implÃ©mentation de la mÃ©thode CreatePlayer de PlayersService.
- Il existe un **STUB** du CardsService qui retourne les cartes d'un joueur avec GetPlayersCards. Il faut retourner les cartes du joueur (OwnedCards).

Angular:

- Register:
  - ReactiveForms valide que le courriel a le bon format, le mot de passe de confirmation est identique et que les champs sont tous requis.
  - Affichage des messages dâ€™erreurs si le format du mot de passe nâ€™est pas valide ou si lâ€™utilisateur existe dÃ©jÃ .
  - Faites la validation de la longueur du mot de passe en utilisant Reactive Forms. Vous pouvez Ã©galement valider les autres critÃ¨res comme lâ€™utilisation de caractÃ¨res spÃ©ciaux, mais câ€™est optionnel.
- Login Reactive forms:
  - Validation des deux champs requis.
  - Affichage des messages dâ€™erreurs provenant du serveur.
- Un register doit AUTOMATIQUEMENT faire un login de l'utilisateur. Donc l'utilisateur n'a pas Ã  faire un login aprÃ¨s son register.
- Rester connectÃ© en utilisant le **sessionStorage** pour conserver le token, le PLAYER id et le nom du player
- Afficher le nom de lâ€™utilisateur dans le haut de la page, tant que l'utilisateur ne se dÃ©connecte pas.
- ImplÃ©menter la dÃ©connexion cÃ´tÃ© client
- ATTENTION: Ajouter un bouton de test sur la page principal et faire un appel Ã  une mÃ©thode avec [Authorize] qui retourne une **liste** de strings. Simplement pour vÃ©rifier que vos tokens fonctionnent bien. Affichez le rÃ©sultat de l'appel avec un snackbar.

```csharp
[Authorize]
[HttpGet]
public ActionResult<string[]> PrivateData()
{
    return new string[] { "figue", "banane", "noix" };
}
```

</details>

<details>
<summary>Angular</summary>

- Afficher les cartes existantes avec Angular (Page Magasin) [Pas encore possible dâ€™acheter ou de vendre des cartes]
- Afficher les cartes du joueur avec Angular (Page Mes Cartes).
- Pour les deux pages de cartes (Page Magasin et page Mes Cartes), ajouter une option de tri selon les trois champs suivants: "Attack", "Health" et "ManaCost".
  - L'utilisateur doit voir les options en **franÃ§ais**.
  - Il faut Ã©galement permettre de faire le tri par ordre **croissant** ou **dÃ©croissant**.
  - Il faut crÃ©er un component pour faire le tri et afficher les cartes et le rÃ©utiliser dans les deux pages. (Il y a donc 1 component par page + 1 component rÃ©utilisÃ© pour un total de 3)

|![alt text](image-2.png)|
|-|


- Afficher un dialogue qui montre que lâ€™on recherche un adversaire. AprÃ¨s 5 secondes, lancer le match de test comme avant.
- Ajouter la logique pour GainManaEvent dans applyEvent de MatchService. (Vous allez maintenant voir le mana qui monte au dÃ©but du tour)
- Ajouter un dialogue de dÃ©faite et de victoire lorsquâ€™on a une fin de partie. Il existe dÃ©jÃ :
  - Une class css .end pour vous aider.
  - Les mÃ©thodes **endMatch** et **isVictory**.

</details>

<details>
<summary>Hub (SignalR)</summary>

- Ajouter les events `DrawCardEvent` et `GainManaEvent` dans `PlayerStartTurnEvent` en passant la quantitÃ© de Mana Ã  partir du `MatchesService`.
- Ajouter les events `DrawCardEvent` dans `StartMatchEvent` en passant le nombre de cartes Ã  partir du `MatchesServices`.
- Pour faire fonctionner **SignalR**, vous allez devoir modifiez vos **CORS** dans **Program.cs**. Il faut simplement ajouter:

```csharp
policy.AllowCredentials();
```

- Ajouter la logique pour supporter la connection, `JoinMatch`, `EndTurn` et `Surrender`.
- Utiliser le hub du cÃ´tÃ© Angular. Regarder le code dans:
  - `home.component.ts` (Pour crÃ©er la connection et joindre un match)
  - `match.component.ts` (Pour gÃ©rer le `EndTurn`, le `Surrender` et les `MatchEvent`)
- CrÃ©er un service Angular pour votre Hub, c'est plus propre et Ã§a va permettre d'utiliser dans MatchComponent, la connection crÃ©Ã©e dans le `HomeComponent`.
- Dans `match.component.ts`, c'est **possible** d'Ã©tablir une connection s'il n'y en a pas dÃ©jÃ  une. C'est le cas si on fait un refresh sur cette page. Mais ce n'est pas obligatoire pour le TP1. Vous pouvez vous crÃ©er un genre de singleton qui s'assure que la connexion existe avant qu'elle puisse Ãªtre utilisÃ©e. Par exemple :

```text
hubConnection?: signalR.HubConnection;

obtenirLaConnexion() retourne signalR.HubConnection
    si la connexion n'existe pas
        crÃ©er la connexion

    retourner la connexion
```

:::warning

- Lâ€™affichage du Mana ne devrait pas encore fonctionner, mais tout devrait sâ€™arranger une fois que lâ€™on va faire lâ€™intÃ©gration.
  :::

#### Logique pour joindre un match

Prenez le temps de regarder le code pour comprendre comment les mÃ©thodes `JoinMatch` et `StartMatch` du service `MatchesService` fonctionnent. Voici un rÃ©sumÃ© de la logique pour joindre un nouveau match:

<Tabs>
  <TabItem value="description" label="Description" default>

1. Bob ğŸ‘¨ veut jouer et un appel Ã  l'action `JoinMatch` du Hub est fait. `JoinMatch` retourne null (n'envoie rien Ã  Bob ğŸ‘¨), mais Bob ğŸ‘¨ est maintenant en attente d'un partenaire. (Le serveur se souvient de Bob ğŸ‘¨)
2. Alice ğŸ‘© veut jouer et un appel Ã  l'action `JoinMatch` du Hub est fait.
3. `JoinMatch` envoie un `JoiningMatchData` Ã  Alice ğŸ‘© dont la propriÃ©tÃ© `OtherPlayerConnectionId` est celle de la connection de Bob ğŸ‘¨ et `IsStarted` est `false`
4. On envoit un message aux deux joueurs avec le `JoiningMatchData` (Si vous regardez le client, il y a un objet similaire qui se nomme `MatchData` qui est utilisÃ© dans `MatchService`)
5. On appel Ã©galement la mÃ©thode `StartMatch` du service `MatchesService` car c'est un nouveau match et on envoit ensuite un message aux 2 joueurs pour traiter le `StartMatchEvent`.

  </TabItem>
  <TabItem value="diagramme" label="Diagramme">

```mermaid
sequenceDiagram
    participant Bob ğŸ‘¨
    participant Serveur ğŸ¤–
    participant Alice ğŸ‘©

    Bob ğŸ‘¨ ->> Serveur ğŸ¤–: 1. JoinMatch
    Alice ğŸ‘© ->> Serveur ğŸ¤–: 2. JoinMatch


    par RÃ©ponses en parallÃ¨le suite Ã  2.
        Serveur ğŸ¤– ->> Alice ğŸ‘©: 3. JoinMatch : JoiningMatchData. <br/> Navigue vers la page pour jouer un match.
        Serveur ğŸ¤– ->> Bob ğŸ‘¨: 3. JoinMatch : JoiningMatchData. <br/> Navigue vers la page pour jouer un match.
        Note over Serveur ğŸ¤–: Puisque la partie n'a pas encore dÃ©butÃ© (IsStarted == false), <br/> on appelle la mÃ©tode StartMatch du service MatchesService.
        Serveur ğŸ¤– ->> Alice ğŸ‘©: 3. ApplyEvent : StartMatchEvent. <br/> Alice ğŸ‘© reÃ§oit des cartes, etc.
        Serveur ğŸ¤– ->> Bob ğŸ‘¨: 3. ApplyEvent : StartMatchEvent. <br/> Bob ğŸ‘¨ reÃ§oit des cartes, etc.
    end
```

  </TabItem>
</Tabs>

Note: Vous avez donc besoin de dÃ©finir un message qui permet d'envoyer le `JoiningMatchData` pour faire le `playMatch` sur le client ET un message pour envoyer un `StartMatchEvent` et faire un `applyEvents` sur le client.

Si on veut rejoindre un match qui Ã©tait dÃ©jÃ  commencÃ© et pas terminÃ©. Par exemple, si je ferme ma fenÃªtre et j'en ouvre une nouvelle et je fais "joindre une partie", je veux retourner dans la mÃªme partie dans laquelle j'Ã©tais.

<Tabs>
  <TabItem value="description" label="Description" default>

0. Bob ğŸ‘¨ et Alice ğŸ‘© Ã©taient dans un match, mais le navigateur de Bob ğŸ‘¨ a crashÃ©. ğŸ’¥
1. Bob ğŸ‘¨ veut retourner sur sa partie. Un appel Ã  `JoinMatch` est fait.
2. On envoit un message Ã  Bob ğŸ‘¨ avec le `JoiningMatchData` (L'autre joueur a probablement encore sa fenÃªtre ouverte, on a pas besoin de rien lui envoyer!)

  </TabItem>
  <TabItem value="diagramme" label="Diagramme">

```mermaid
sequenceDiagram
    participant Bob ğŸ‘¨
    participant Serveur ğŸ¤–
    participant Alice ğŸ‘©

    Note over Bob ğŸ‘¨: 0. L'ordinateur a crashÃ©! ğŸ’¥
    Bob ğŸ‘¨ ->> Serveur ğŸ¤–: 1. JoinMatch
    Note over Serveur ğŸ¤–: Puisque la partie a dÃ©jÃ  dÃ©butÃ© (IsStarted == true), <br/> on n'appelle PAS la mÃ©tode StartMatch du service MatchesService.
    Serveur ğŸ¤– ->> Bob ğŸ‘¨: 2. JoinMatch : JoiningMatchData. <br/> Navigue vers la page pour jouer un match.
```

  </TabItem>
</Tabs>

#### Players et Users de test

Comme le register/login, n'est pas encore implÃ©mentÃ©, il faut faire de petits ajustements pour pouvoir travailler:

- Vous allez voir qu'il existe 2 users et 2 players dans le seed pour vous permettre de tester le Hub avec les ids: "User1Id" et "User2Id"
- Il va vous falloir passer le user Id Ã  vos actions de Hub car on ne peut pas utilier de `[Authorize]`, ni accÃ©der Ã  l'utilisateur connectÃ©.
  - Faites une mÃ©thode sÃ©parÃ©e pour le JoinMatch, ne le faites pas automatiquement dans la connexion, sinon vous ne pouvez pas passer le user Id.
- Il faut modifier le client pour avoir l'option de se connecter avec un User 1 ou 2. Vous pouvez simplement ajouter un deuxiÃ¨me bouton et modifier le joinMatch de HomeComponent: (Le playerId dans le sessionStorage va Ãªtre utile au moment d'utiliser MatchService)

```ts
joinMatch(user1:boolean) {
    // TODO: Angular: Afficher un dialogue qui montre que l'on attend de joindre un match
    // TODO: Hub: Se connecter au Hub et joindre un match
    let userId:string = user1 ? "User1Id" : "User2Id";
    if(user1)
      sessionStorage.setItem("playerId", "1");
    else
      sessionStorage.setItem("playerId", "2");
```

</details>

## IntÃ©gration (Ã  faire seulement une fois que les fonctionnalitÃ©s individuelles sont terminÃ©es pour prÃ©parer Ã  lâ€™Ã©valuation de groupe)

- Ramenez les diffÃ©rentes branches vers la branche Dev.
- Assurez-vous de vous connecter Ã  un vrai match avec le Hub.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation de MatchConfigurationService.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation de MatchService cÃ´tÃ© Angular.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation de StartingCardsService.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation pour le WebAPI pour obtenir les cartes du joueur.
- Dans MatchPlayerData, utiliser les cartes du joueur.
- Utilisez un guard pour limiter l'accÃ¨s Ã  la page Mes Cartes et Match Ã  un utilisateur connectÃ©.
- Assurez-vous de vous dÃ©connecter du Hub si vous faites cancel et de ne plus attendre pour un Match.
- Assurez-vous de bien setter le playerId dans le sessionStorage lors de votre connexion.
- Utilisez \[Authorize\] dans le **Hub** pour s'assurer que l'utilisateur est bien connectÃ© et arrÃªter de passer le userId dans les appels et obtenez-le directement dans le Hub.
- Ajoutez le code nÃ©cessaire pour faire fonctionner le \[Authorize\] avec SignalR et les tokens (Voir [SignalR #2](/exercices/SignalR2))

## Grille de correction

- 12% de la note pour lâ€™Ã©valuation individuelle (voir le document sur la correction individuelle)
  - 2% pour l'utilisation d'Azure DevOps Boards
  - 10% pour le code et les fonctionnalitÃ©s
- 8% de la note pour lâ€™Ã©valuation de groupe
  - 3% pour le diagramme de classe
  - 5% pour l'intÃ©gration des fonctionnalitÃ©s du projet et les derniÃ¨res fonctionnalitÃ©s

## RÃ©fÃ©rence pour la remise finale en Ã©quipe

Une rÃ©fÃ©rence pour voir un client et un serveur fonctionnels.

- ğŸ”—[Client Angular](https://ngsci.onrender.com/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

- ğŸ”—[Serveur MVC](https://sci-mvc.onrender.com/)

:::warning
Si vous voyez la page suivante, il faut simplement attendre que l'application dÃ©marre
:::

<details>
<summary>Il faut parfois attendre avant de pouvoir accÃ©der Ã  la dÃ©mo...</summary>
![alt text](image-5.png)
</details>

<!-- Avec supabase, ce n'est plus un problÃ¨me!

:::danger Attention!
La dÃ©monstration de la partie MVC et de la partie Angular ne partagent pas la mÃªme base de donnÃ©e, comme ce devrait Ãªtre le cas. Les StartingCards choisies dans l'interface administrateur n'auront donc aucune incidence sur la partie Angular, **dans la dÃ©monstration**. **Dans votre partie Ã  vous**, les StartingCards choisies dans l'interface administrateur doivent se reflÃ©ter dans la partie Angular, lors de la crÃ©ation de compte.
:::

-->
