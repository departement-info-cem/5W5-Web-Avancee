# TP1 (Super Cartes Infinies)

## Date de remise/√©valuation

- Diagramme de classes (12 f√©vrier)
- √âvaluation individuelle (21 f√©vrier)
- √âvaluation de groupe (4 mars)

## L'application

### Objectifs : 
- Analyser un probl√®me et le d√©couper en Epics, User Stories et Tasks √† l'aide d'Azure DevOps Boards.
- Cr√©er un diagramme de classes de la solution.
- Compl√®ter un application web √† l‚Äôaide d‚ÄôAngular, Web API et MVC pour faire un jeu de carte de style HearthStone.
- Le site Angular sera utilis√© par des membres inscrits en utilisant des cookies pour l'authentification. 
- L‚Äôadministrateur pourra configurer le contenu de l‚Äôapplication √† l‚Äôaide de MVC.
- Il n'est pas n√©cessaire d'√©crire des tests pour le premier TP, mais nous allons en √©crire pour les 2 prochains.

### Les r√®gles :
- Deux joueurs s‚Äôaffrontent avec leurs cartes.
- Chaque joueur pige un nombre de cartes configurable d√®s le d√©part.
- Chaque joueur pige une carte au d√©but de son tour.
- Chaque joueur re√ßoit une quantit√© configurable de mana au d√©but de son tour.
- Chaque carte a une certaine quantit√© de points d‚Äôattaque, une certaine quantit√© de points de d√©fense et un co√ªt en mana.
- Les joueurs ne pourront **pas encore** jouer de carte avant le TP2. Nous allons voir les r√®gles du jeu plus en d√©tails √† ce moment.
- Un joueur peut terminer son tour. Le tour de l‚Äôautre joueur commence alors et il re√ßoit sa carte et son mana.
- Un joueur peut abandonner la partie et il perd alors automatiquement (l‚Äôautre joueur a une victoire).

### Clarification :
Le mot ¬´ carte ¬ª est utilis√© tr√®s fr√©quemment, mais il faut comprendre que l‚Äôon ne parle pas toujours du m√™me mod√®le de donn√©e. En effet, lorsqu‚Äôon configure le jeu, le mot carte fait r√©f√©rence au ¬´ mod√®le ¬ª de la carte. Mais si on mentionne qu‚Äôun joueur poss√®de des cartes, on a besoin d‚Äôun mod√®le qui permet d‚Äôassocier une carte √† un joueur. Le premier livrable du projet est un diagramme de classe qui va permettre de clarifier tout √ßa.

### Contraintes
- Le travail doit √™tre effectu√© en √©quipes de 3 ou 4.
- Vous devrez utiliser Git/GitHub.
- Vous devrez utiliser DevOps pour la gestion des t√¢ches.
- Vous devrez compl√©ter une application cliente en Angular.
- Vous devrez compl√©ter une application serveur en ASP.NET Web API.
- Vous devrez ajouter une section **(Area)** d‚Äôadministrateur sur votre serveur en MVC.

## Livraisons du TP

### Mat√©riel de d√©part

Le diagramme de classe √† compl√©ter:
- üîó[Diagramme de classes Visio](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/EfL4bakKNiBEqEwCHT8pGuEBpkKEqGalcVDq-66vYUc9uA?e=GjCSED)

:::info
C'est possible de cr√©er un nouveau repository GitHub directement dans Gitkraken.
:::

Pour le client et le serveur:
    - **1** membre de l'√©quipe doit faire un nouveau repository **PRIVATE** pour **CHAQUE** partie. **1 client et 1 serveur**.  Voici les fichiers de d√©part:
        - üîó[Client de d√©part](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/ETtvfI4zBsNPtNLX_jdy7IUBXsQn8XqeUYs3hWYxIdz1VQ?e=4HMtWp)
        - üîó[Serveur de d√©part](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/EXJ9kOO1dEZLukA_AyQkvXgBko0rYJsadEaVWTbDiepdZw?e=lNMdIA)
    - Ajouter ensuite le contenu du zip √† **CHACUN DES projets** et faire un commit/push.
    - Partager les 2 nouveaux repositories aux autres membres de l'√©quipe.
    - Partager les √©galement avec l'enseignant. Utilisateur: **mbriau**.

### Les √©tapes
Il y a 3 √©tapes de livraison du premier TP :
- Diagramme de classe et DevOps (√©valuation de groupe)
- Fonctionnalit√©s (√©valuation individuelle)
- Int√©gration des fonctionnalit√©s, DevOps et Git (√©valuation de groupe)


## Le d√©tail des t√¢ches individuelles
### Section d‚Äôadministration (MVC)
- L‚Äôadministrateur peut cr√©er, modifier, voir et supprimer les cartes mod√®les.
- Cartes de d√©parts:
    - Mettre en place le mod√®le de donn√©es des cartes de d√©part.
    - L‚Äôadministrateur peut modifier les cartes de d√©part des nouveaux joueurs. Faire un tri par le nom de la carte dans l‚ÄôIndex.
    - Ajouter un seed des cartes de d√©part. Il doit contenir 3 cartes diff√©rentes avec une seul copie et 3 autres cartes avec deux copies chaque.
    - Il existe un **STUB** de StartingCardsService pour les cartes de d√©part. Il faut retourner les cartes configurer √† l'aide des cartes de d√©part.
- Configuration:
    - Mettre en place le mod√®le de donn√©es de la configuration.
    - Ajouter une page de configuration pour l‚Äôadministrateur. Permettre de d‚Äôavoir une configuration pour le nombre de cartes de d√©part et la quantit√© de Mana re√ßu au d√©but du tour.
    - Ajouter un seed pour la configuration avec 4 cartes de d√©part et 3 manas par tour.
    - Note : Ce n‚Äôest pas un probl√®me que la configuration soit une table avec une seule entr√©e. Dans une version plus avanc√©e du projet, on pourrait imaginer qu‚Äôil y ait plusieurs modes de jeu diff√©rents avec des configurations diff√©rentes, pour l‚Äôinstant on va toujours utiliser la seule configuration existante. Vous pouvez faire simplement utiliser First() sur le DbSet.
    - Il existe un **STUB** du ConfigurationService qui retourne le nombre de cartes re√ßu au d√©but de la partie et le nombre de mana re√ßu par tour. Il faut retourner les valeurs de la configuration.


### Enregistrement et connexion

.NET:
- Mettre en place le mod√®le de donn√©es **OwnedCard** pour permettre aux players d'avoir ses propres cartes.
- Ajouter un contr√¥leur d'API pour g√©rer l'enregistrement, la connexion et la d√©connexion.
- Lors de l'enregistrement, il faut appeler la m√©thode CreatePlayer de PlayersService.
- Il faut terminer l'impl√©mentation de la m√©thode CreatePlayer de PlayersService.
- Il existe un **STUB** du CardsService qui retourne les cartes d'un joueur avec GetPlayersCards. Il faut retourner les cartes du joueurs (OwnedCards).

Angular:
- Register:
    - ReactiveForms valide que le courriel a le bon format, le mot de passe de confirmation est identique et que les champs sont tous requis.
    - Affichage des messages d‚Äôerreurs si le format du mot de passe n‚Äôest pas valide ou si l‚Äôutilisateur existe d√©j√†.
    - Faites la validation de la longueur du mot de passe en utilisant Reactive Forms. Vous pouvez √©galement valider les autres crit√®res comme l‚Äôutilisation de caract√®res sp√©ciaux, mais c‚Äôest optionnel.
- Login Reactive forms:
    - Validation du format du courriel et des deux champs requis.
    - Affichage des messages d‚Äôerreurs provenant du serveur.
- Impl√©menter la d√©connection
- Rester connect√© en utilisant le **localStorage** et afficher le courriel de l‚Äôutilisateur tant que l'utilisateur ne se d√©connecte pas. Vous pouvez assumer que le cookie est pr√©sent quand l'utilisateur est connect√©.

### Angular

- Afficher les cartes existantes avec Angular (Page Magasin) [Pas encore possible d‚Äôacheter ou de vendre des cartes]
- Afficher les cartes du joueur avec Angular (Page Mes Cartes).
- Afficher un dialogue qui montre que l‚Äôon recherche un adversaire. Apr√®s 30 secondes, lancer le match de test comme avant.
- Ajouter la logique pour GainManaEvent dans processEvent de MatchService.
- Ajouter un dialogue de d√©faite et de victoire lorsqu‚Äôon a une fin de partie. Il existe d√©j√†:
    - Une class css .end pour vous aider.
    - Les m√©thodes **endMatch** et **isVictory**.

### Hub

- Ajouter les events DrawCardEvent et GainManaEvent dans PlayerStartTurnEvent en passant la quantit√© de Mana √† partir du MatchesService.
- Ajouter les events DrawCardEvent dans StartMatchEvent en passant le nombre de cartes √† partir du MatchesServices.
- Ajouter la logique pour supporter la Connection, le StartMatch, les EndTurn et le Surrender.
- Utiliser le hub du c√¥t√© Angular. Regarder le code dans:
    - home.component.ts (Pour cr√©er la connection et joindre un match)
    - match.component.ts (Pour g√©rer le EndTurn, le Surrender et les events)
- Cr√©er un service pour votre Hub, c'est plus propre et √ßa va permettre d'utiliser dans MatchComponent, la connection cr√©√©e dans le HomeComponent.
- Dans match.component.ts, c'est **possible** d'√©tablir une connection s'il n'y en a pas d√©j√† une. C'est le cas si on fait un refresh sur cette page. Mais ce n'est pas obligatoire pour le TP1. 
    
:::warning
- L‚Äôaffichage du Mana ne devrait pas encore fonctionner, mais tout devrait s‚Äôarranger une fois que l‚Äôon va faire l‚Äôint√©gration.
:::

#### Players et Users de test
Comme le register/login, n'est pas encore impl√©ment√©, il faut faire de petits ajustements pour pouvoir travailler:
- Premi√®rement, il va vous falloir passer le user Id √† vos actions de Hub car on ne peut pas utilier de [Authorize], ni acc√©der √† l'utilisateur connect√©.
    - Faites une m√©thode s√©par√©e pour le JoinMatch, ne le faites pas automatiquement dans la connexion, sinon vous ne pouvez pas passer le user Id.
- Deuxi√®mement, il faut modifier le client pour avoir l'option de se connecter avec un User 1 ou 2. Vous pouvez simplement ajouter un deuxi√®me bouton et modifier le joinMatch de HomeComponent: (Le playerId dans le localStorage va √™tre utile au moment d'utiliser MatchService)
```ts
joinMatch(user1:boolean) {
    // TODO: Angular: Afficher un dialogue qui montre que l'on attend de joindre un match
    // TODO: Hub: Se connecter au Hub et joindre un match
    let userId:string = user1 ? "User1Id" : "User2Id";
    if(user1)
      localStorage.setItem("playerId", "1");
    else
      localStorage.setItem("playerId", "2");
```

- Finalement, vous allez devoir faire des players et users de test. Avec le seed suivant, vous allez avoir 2 user Ids pour vos tests: "User1Id" et "User2Id"
```csharp
public static IdentityUser[] SeedTestUsers()
{
    return new IdentityUser[] {
        new IdentityUser()
        {
            Id = "User1Id"

        },
        new IdentityUser
        {
            Id = "User2Id"
        }
    };
}

public static Player[] SeedTestPlayers()
{
    return new Player[] {
        new Player
        {
            Id = 1,
            Name = "Test player 1",
            IdentityUserId = "User1Id"

        },
        new Player
        {
            Id = 2,
            Name = "Test player 2",
            IdentityUserId = "User2Id"
        }
    };
}
```
:::warning
N'oubliez pas d'ajouter ces seeds dans le **OnModelCreating** de votre Context et de faire une migration
:::

## Int√©gration (√† faire seulement une fois que les fonctionnalit√©s sont termin√©s pour l‚Äô√©valuation de groupe)
- Ramenez les diff√©rentes branches vers la branche Dev.
- Assurez-vous de vous connecter √† un vrai match avec le Hub.
- Assurez-vous d‚Äôutiliser la bonne impl√©mentation de ConfigurationService.
- Assurez-vous d‚Äôutiliser la bonne impl√©mentation de MatchService c√¥t√© Angular.
- Assurez-vous d‚Äôutiliser la bonne impl√©mentation de StartingCardsService.
- Assurez-vous d‚Äôutiliser la bonne impl√©mentation pour le WebAPI pour obtenir les cartes du joueur.
- Dans MatchPlayerData, utiliser les cartes du joueur.
- Utiliser un guard pour limiter l'acc√®s √† la page Mes Cartes et Match √† un utilisateur connect√©.
- Assurez-vous de vous d√©connecter du Hub si vous faites cancel et de ne plus attendre pour un Match.
- Utiliser Authorize dans le Hub pour s'assurer que l'utilisateur est bien connect√© et arr√™ter de passer le userId dans les appels et obtenez le directement dans le Hub.
- Assurez-vous de bien setter le playerId dans le localStorage lors de votre connection.

## Grille de correction
- 12% de la note pour l‚Äô√©valuation individuelle (voir le document sur la correction individuelle)
- 8% de la note pour l‚Äô√©valuation de groupe
    -	2% pour le diagramme de classe
    -	3% pour l'utilisation d'Azure DevOps Boards
    -	3% pour l'int√©gration des fonctionnalit√©s du projet

## R√©f√©rence pour la remise finale en √©quipe

Une r√©f√©rence pour voir un client et un serveur fonctionnels.

- üîó[Client](https://wonderful-tree-0ccc8c610.4.azurestaticapps.net/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

- üîó[Serveur](https://supercartesinfinies.azurewebsites.net/)

:::danger
C'est possible que les exemples ne fonctionnent pas bien selon vos options de cookies. Nous allons les regarder en classe. Pour le truc: [Cookies](/info/Trucs#pour-accepter-les-cookies-third-parties)
:::


## Modifications au TP

- Malheureusement, les enseignants aussi font des erreurs!
- Dans cette section, je vais ajouter les modifications qui doivent √™tre faite au TP pour qu'il fonctionne bien et facilement.

### Erreur de polymorphisme et de s√©rialization d'√©v√©nements

:::warning
Vous pouvez faire la modification uniquement dans votre branche **Hub**. Les autres t√¢ches ne sont pas affect√©es!
:::

- En voulant simplifier la logique, j'ai cr√©√© un probl√®me int√©ressant. Dans le fichier MatchesService.cs il faut ajouter **as MatchEvent** aux endroits o√π l'on serialize les events. Sinon, l'event parent n'a pas de propri√©t√© **$type**.
- Je vais donner plus d'explications en classe, c'est un cas int√©ressant.
- Il y a **3** appels a **JsonSerializer.Serialize** dans le fichier

```csharp
return JsonSerializer.Serialize(playerTurnEvent);
```

devient donc:

```csharp
return JsonSerializer.Serialize(playerTurnEvent as MatchEvent);
```
