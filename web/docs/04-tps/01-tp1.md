# TP1 (Super Cartes Infinies)

## Le projet
DÃ©velopper un jeu de cartes (avec un style similaire Ã  Hearthstone).
Le projet se fait en Ã©quipe de 3 ou 4.

## Ã‰valuations

- Diagramme de classes ()
- Ã‰valuation individuelle ()
- Ã‰valuation de groupe ()

## L'application

### Objectifs : 
- Analyser un problÃ¨me et le dÃ©couper en Epics, User Stories et Tasks Ã  l'aide d'Azure DevOps Boards.
- CrÃ©er un diagramme de classes de la solution.
- ComplÃ¨ter un application web Ã  lâ€™aide dâ€™Angular, Web API et MVC pour faire un jeu de carte de style HearthStone.
- Le site Angular sera utilisÃ© par des membres inscrits en utilisant des tokens pour l'authentification. 
- Lâ€™administrateur pourra configurer le contenu de lâ€™application Ã  lâ€™aide de MVC.
- Il n'est pas nÃ©cessaire d'Ã©crire des tests pour le premier TP, mais nous allons en Ã©crire pour les 2 prochains.

### Les rÃ¨gles :
- Deux joueurs sâ€™affrontent avec leurs cartes.
- Chaque joueur pige un nombre de cartes configurable dÃ¨s le dÃ©part.
- Chaque joueur pige une carte au dÃ©but de son tour.
- Chaque joueur reÃ§oit une quantitÃ© configurable de mana au dÃ©but de son tour.
- Chaque carte a une certaine quantitÃ© de points dâ€™attaque, une certaine quantitÃ© de points de dÃ©fense et un coÃ»t en mana.
- Les joueurs ne pourront **pas encore** jouer de carte avant le TP2. Nous allons voir les rÃ¨gles du jeu plus en dÃ©tails Ã  ce moment.
- Un joueur peut terminer son tour. Le tour de lâ€™autre joueur commence alors et il reÃ§oit sa carte et son mana.
- Un joueur peut abandonner la partie et il perd alors automatiquement (lâ€™autre joueur a une victoire).

### Clarification :
Le mot Â« carte Â» est utilisÃ© trÃ¨s frÃ©quemment, mais il faut comprendre que lâ€™on ne parle pas toujours du mÃªme modÃ¨le de donnÃ©e. En effet, lorsquâ€™on configure le jeu, le mot carte fait rÃ©fÃ©rence au Â« modÃ¨le Â» de la carte. Mais si on mentionne quâ€™un joueur possÃ¨de des cartes, on a besoin dâ€™un modÃ¨le qui permet dâ€™associer une carte Ã  un joueur. Le premier livrable du projet est un diagramme de classe qui va permettre de clarifier tout Ã§a.

### Contraintes
- Le travail doit Ãªtre effectuÃ© en Ã©quipes de 3 ou 4.
- Vous devrez utiliser Git/GitHub.
- Vous devrez utiliser DevOps pour la gestion des tÃ¢ches.
- Vous devrez complÃ©ter une application cliente en Angular.
- Vous devrez complÃ©ter une application serveur en ASP.NET Web API.
- Vous devrez ajouter une section **(Area)** dâ€™administrateur sur votre serveur en MVC.

## Livraisons du TP

### MatÃ©riel de dÃ©part

Le diagramme de classe Ã  complÃ©ter:
- ğŸ”—[Diagramme de classes Visio](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/EfL4bakKNiBEqEwCHT8pGuEBpkKEqGalcVDq-66vYUc9uA?e=GjCSED)

:::info
C'est possible de crÃ©er un nouveau repository GitHub directement dans Gitkraken.
:::

Pour le client et le serveur:
    - **1** membre de l'Ã©quipe doit faire un nouveau repository **PRIVATE** pour **CHAQUE** partie. **1 client et 1 serveur**.  Voici les fichiers de dÃ©part:
        - ğŸ”—[Client de dÃ©part](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/ETtvfI4zBsNPtNLX_jdy7IUBXsQn8XqeUYs3hWYxIdz1VQ?e=4HMtWp)
        - ğŸ”—[Serveur de dÃ©part](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/EXJ9kOO1dEZLukA_AyQkvXgBko0rYJsadEaVWTbDiepdZw?e=lNMdIA)
    - Ajouter ensuite le contenu du zip Ã  **CHACUN DES projets** et faire un commit/push.
    - Partager les 2 nouveaux repositories aux autres membres de l'Ã©quipe.
    - Partager les Ã©galement avec l'enseignant. Utilisateur: **mbriau**.

### Les Ã©tapes
Il y a 3 Ã©tapes de livraison du premier TP :
- Diagramme de classe et DevOps (Ã©valuation de groupe)
- FonctionnalitÃ©s (Ã©valuation individuelle)
- IntÃ©gration des fonctionnalitÃ©s, DevOps et Git (Ã©valuation de groupe)


## Le dÃ©tail des tÃ¢ches individuelles
### Section dâ€™administration (MVC)
- Lâ€™administrateur peut crÃ©er, modifier, voir et supprimer les cartes modÃ¨les.
- Cartes de dÃ©parts:
    - Mettre en place le modÃ¨le de donnÃ©es des cartes de dÃ©part.
    - Lâ€™administrateur peut modifier les cartes de dÃ©part des nouveaux joueurs. Faire un tri par le nom de la carte dans lâ€™Index.
    - Ajouter un seed des cartes de dÃ©part. Il doit contenir 3 cartes diffÃ©rentes avec une seul copie et 3 autres cartes avec deux copies chaque.
    - Il existe un **STUB** de StartingCardsService pour les cartes de dÃ©part. Il faut retourner les cartes configurer Ã  l'aide des cartes de dÃ©part.
- Configuration:
    - Mettre en place le modÃ¨le de donnÃ©es de la configuration.
    - Ajouter une page de configuration pour lâ€™administrateur. Permettre de dâ€™avoir une configuration pour le nombre de cartes de dÃ©part et la quantitÃ© de Mana reÃ§u au dÃ©but du tour.
    - Ajouter un seed pour la configuration avec 4 cartes de dÃ©part et 3 manas par tour.
    - Note : Ce nâ€™est pas un problÃ¨me que la configuration soit une table avec une seule entrÃ©e. Dans une version plus avancÃ©e du projet, on pourrait imaginer quâ€™il y ait plusieurs modes de jeu diffÃ©rents avec des configurations diffÃ©rentes, pour lâ€™instant on va toujours utiliser la seule configuration existante. Vous pouvez faire simplement utiliser First() sur le DbSet.
    - Il existe un **STUB** du ConfigurationService qui retourne le nombre de cartes reÃ§u au dÃ©but de la partie et le nombre de mana reÃ§u par tour. Il faut retourner les valeurs de la configuration.


### Enregistrement et connexion

.NET:
- Mettre en place le modÃ¨le de donnÃ©es **OwnedCard** pour permettre aux players d'avoir ses propres cartes.
- Ajouter un contrÃ´leur d'API pour gÃ©rer l'enregistrement, la connexion et la dÃ©connexion.
- Lors de l'enregistrement, il faut appeler la mÃ©thode CreatePlayer de PlayersService.
- Il faut terminer l'implÃ©mentation de la mÃ©thode CreatePlayer de PlayersService.
- Il existe un **STUB** du CardsService qui retourne les cartes d'un joueur avec GetPlayersCards. Il faut retourner les cartes du joueurs (OwnedCards).

Angular:
- Register:
    - ReactiveForms valide que le courriel a le bon format, le mot de passe de confirmation est identique et que les champs sont tous requis.
    - Affichage des messages dâ€™erreurs si le format du mot de passe nâ€™est pas valide ou si lâ€™utilisateur existe dÃ©jÃ .
    - Faites la validation de la longueur du mot de passe en utilisant Reactive Forms. Vous pouvez Ã©galement valider les autres critÃ¨res comme lâ€™utilisation de caractÃ¨res spÃ©ciaux, mais câ€™est optionnel.
- Login Reactive forms:
    - Validation du format du courriel et des deux champs requis.
    - Affichage des messages dâ€™erreurs provenant du serveur.
    - Un checkbox qui permet de garder le username dans le **localStorage** (Sauvegarder le nom d'utilisateur)
        - Si l'option est active, le formulaire affiche ce username par dÃ©faut
- Rester connectÃ© en utilisant le **sessionStorage** et afficher le courriel de lâ€™utilisateur tant que l'utilisateur ne se dÃ©connecte pas.
- ImplÃ©menter la dÃ©connection
- ATTENTION: Ajouter un bouton de test sur la page principal et faire un appel Ã  une mÃ©thode avec [Authorize] qui retourne une **liste** de strings. Simplement pour vÃ©rifier que vos tokens fonctionnent bien.
```csharp
[Authorize]
public ActionResult<string[]> PrivateData()
{
    return new string[] { "figue", "banane", "noix" };
}
```

### Angular

- Afficher les cartes existantes avec Angular (Page Magasin) [Pas encore possible dâ€™acheter ou de vendre des cartes]
- Afficher les cartes du joueur avec Angular (Page Mes Cartes).
- Afficher un dialogue qui montre que lâ€™on recherche un adversaire. AprÃ¨s 30 secondes, lancer le match de test comme avant.
- Ajouter la logique pour GainManaEvent dans processEvent de MatchService.
- Ajouter un dialogue de dÃ©faite et de victoire lorsquâ€™on a une fin de partie. Il existe dÃ©jÃ :
    - Une class css .end pour vous aider.
    - Les mÃ©thodes **endMatch** et **isVictory**.

### Hub

- Ajouter les events DrawCardEvent et GainManaEvent dans PlayerStartTurnEvent en passant la quantitÃ© de Mana Ã  partir du MatchesService.
- Ajouter les events DrawCardEvent dans StartMatchEvent en passant le nombre de cartes Ã  partir du MatchesServices.
- Ajouter la logique pour supporter la Connection, le StartMatch, les EndTurn et le Surrender.
- Utiliser le hub du cÃ´tÃ© Angular. Regarder le code dans:
    - home.component.ts (Pour crÃ©er la connection et joindre un match)
    - match.component.ts (Pour gÃ©rer le EndTurn, le Surrender et les events)
- CrÃ©er un service pour votre Hub, c'est plus propre et Ã§a va permettre d'utiliser dans MatchComponent, la connection crÃ©Ã©e dans le HomeComponent.
- Dans match.component.ts, c'est **possible** d'Ã©tablir une connection s'il n'y en a pas dÃ©jÃ  une. C'est le cas si on fait un refresh sur cette page. Mais ce n'est pas obligatoire pour le TP1. 
    
:::warning
- Lâ€™affichage du Mana ne devrait pas encore fonctionner, mais tout devrait sâ€™arranger une fois que lâ€™on va faire lâ€™intÃ©gration.
:::

#### Players et Users de test
Comme le register/login, n'est pas encore implÃ©mentÃ©, il faut faire de petits ajustements pour pouvoir travailler:
- PremiÃ¨rement, il va vous falloir passer le user Id Ã  vos actions de Hub car on ne peut pas utilier de [Authorize], ni accÃ©der Ã  l'utilisateur connectÃ©.
    - Faites une mÃ©thode sÃ©parÃ©e pour le JoinMatch, ne le faites pas automatiquement dans la connexion, sinon vous ne pouvez pas passer le user Id.
- DeuxiÃ¨mement, il faut modifier le client pour avoir l'option de se connecter avec un User 1 ou 2. Vous pouvez simplement ajouter un deuxiÃ¨me bouton et modifier le joinMatch de HomeComponent: (Le playerId dans le localStorage va Ãªtre utile au moment d'utiliser MatchService)
```ts
joinMatch(user1:boolean) {
    // TODO: Angular: Afficher un dialogue qui montre que l'on attend de joindre un match
    // TODO: Hub: Se connecter au Hub et joindre un match
    let userId:string = user1 ? "User1Id" : "User2Id";
    if(user1)
      localStorage.setItem("playerId", "1");
    else
      localStorage.setItem("playerId", "2");
```

- Finalement, vous allez devoir faire des players et users de test. Avec le seed suivant, vous allez avoir 2 user Ids pour vos tests: "User1Id" et "User2Id"
```csharp
public static IdentityUser[] SeedTestUsers()
{
    return new IdentityUser[] {
        new IdentityUser()
        {
            Id = "User1Id"

        },
        new IdentityUser
        {
            Id = "User2Id"
        }
    };
}

public static Player[] SeedTestPlayers()
{
    return new Player[] {
        new Player
        {
            Id = 1,
            Name = "Test player 1",
            IdentityUserId = "User1Id"

        },
        new Player
        {
            Id = 2,
            Name = "Test player 2",
            IdentityUserId = "User2Id"
        }
    };
}
```
:::warning
N'oubliez pas d'ajouter ces seeds dans le **OnModelCreating** de votre Context et de faire une migration
:::

#### Savoir si un match doit Ãªtre dÃ©marrÃ©
- Pour simplifier l'implÃ©mentation du Hub, voici une faÃ§on simple de savoir si un match doit Ãªtre dÃ©marrÃ© (Si on doit faire un appel Ã  StartMatch).
- Simplement modifier la fin de la mÃ©thode **JoinMatch** de **MatchesService.cs** et ajouter une propirÃ©tÃ© **IsStarted** Ã  **JoiningMatchData**

```csharp 
if(match != null) {
    return new JoiningMatchData
    {
        Match = match,
        PlayerA = playerA!,
        PlayerB = playerB!,
        OtherPlayerConnectionId = otherPlayerConnectionId,
        // otherPlayerConnectionId est null seulement si c'est une partie qui existait deja
        IsStarted = otherPlayerConnectionId == null
    };
}

return null;
```

Ajouter Ã  JoinginMatchData
```csharp 
public bool IsStarted { get; set; }
```

## IntÃ©gration (Ã  faire seulement une fois que les fonctionnalitÃ©s sont terminÃ©s pour lâ€™Ã©valuation de groupe)
- Ramenez les diffÃ©rentes branches vers la branche Dev.
- Assurez-vous de vous connecter Ã  un vrai match avec le Hub.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation de ConfigurationService.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation de MatchService cÃ´tÃ© Angular.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation de StartingCardsService.
- Assurez-vous dâ€™utiliser la bonne implÃ©mentation pour le WebAPI pour obtenir les cartes du joueur.
- Dans MatchPlayerData, utiliser les cartes du joueur.
- Utiliser un guard pour limiter l'accÃ¨s Ã  la page Mes Cartes et Match Ã  un utilisateur connectÃ©.
- Assurez-vous de vous dÃ©connecter du Hub si vous faites cancel et de ne plus attendre pour un Match.
- Utiliser Authorize dans le Hub pour s'assurer que l'utilisateur est bien connectÃ© et arrÃªter de passer le userId dans les appels et obtenez le directement dans le Hub.
- Assurez-vous de bien setter le playerId dans le localStorage lors de votre connection.

## Grille de correction
- 12% de la note pour lâ€™Ã©valuation individuelle (voir le document sur la correction individuelle)
- 8% de la note pour lâ€™Ã©valuation de groupe
    -	2% pour le diagramme de classe
    -	3% pour l'utilisation d'Azure DevOps Boards
    -	3% pour l'intÃ©gration des fonctionnalitÃ©s du projet

-->

<!--
## RÃ©fÃ©rence pour la remise finale en Ã©quipe

Une rÃ©fÃ©rence pour voir un client et un serveur fonctionnels.

- ğŸ”—[Client](https://wonderful-tree-0ccc8c610.4.azurestaticapps.net/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

- ğŸ”—[Serveur](https://supercartesinfinies.azurewebsites.net/)

-->
