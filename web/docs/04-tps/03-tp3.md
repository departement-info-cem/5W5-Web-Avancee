# TP3 (Super suite de Super Cartes Infinies)

TODO: Mentionner que la version d√©ploy√© va n√©cessit√© une mise √† jour pour fonctionner

## Le projet
Ajouter des fonctionnalit√©s au jeu de cartes d√©velopp√© lors du Sprint 1.

:::info
Vous devez choisir une des t√¢ches suivantes qui sera √©valuer de fa√ßon individuelle. Vous devez √©crire vous-m√™me le code, mais vous pouvez collaborer avec vos coll√®gues.
:::

### Les t√¢ches individuelles
:::warning
La t√¢che de pouvoirs suppl√©mentaires doit √™tre fait par un autre √©tudiant que celui qui a fait la logique de jeu au TP2
:::
- **\[Obligatoire\]** Pouvoirs suppl√©mentaires et cartes de sort
- **\[Obligatoire\]** Classement et matchmaking
- Statistiques des joueurs
- Discussion et mode spectateur

### Contraintes
- Le travail doit √™tre effectu√© en √©quipes de 3 ou 4.
- Vous devez utiliser **Git/GitHub**.
- Vous devez utiliser **DevOps** pour la gestion des t√¢ches ET utiliser les **sprints**.

### Les √©tapes et √©valuations
Il y a 2 √©valuations, mais il est fortement recommand√© de terminer les t√¢ches individuelles au moins une semaine avant la remise d'√©quipe :
- Premier livrable d'√©quipe (Premi√®re √©valuation)
- Fonctionnalit√©s individuelles
- Merge et derni√®re fonctionnalit√© (Deuxi√®me √©valuation)

## Premier livrable d'√©quipe (5%)
- Comme on va travailler en Test Driven Development (TDD). Il faut ajouter au moins un test complet pour chacun des nouveaux pouvoirs. (Voir la premi√®re t√¢che individuelle)
- Il faut ordonner les cartes sur le BattleField en [utilisant un Index](/info/DataOrder)
- Prot√®ger la branche de d√©veloppement avec des tests unitaires automatiques et au moins un review pour le Pull Request. (L'appliquer sur la branche o√π les diff√©rentes parties individuelles vont √™tre merg√©es)

## T√¢ches individuelles (11%)

<details>
<summary>Pouvoirs suppl√©mentaires</summary>
- Il y aura l‚Äôajout de pouvoirs pour les cartes qui vont modifier un √©tat. 
    - Poison X, qui ajoute une valeur de poison √† la carte attaqu√©e. Le poison diminue ensuite la vie d‚Äôune carte de la valeur du poison √† la fin de son activation. Si une carte a d√©j√† une valeur de poison et qu‚Äôelle est √† nouveau attaqu√©e, la valeur de poison est augment√©e.
    - Stunned X, qui emp√™che une carte d‚Äôagir pendant son activation durant X tours. (Mais elle re√ßoit quand m√™me les d√©g√¢ts de poison!)
    - Holy Shield, qui prot√®ge la carte en bloquant 100% des d√©g√¢ts la prochaine fois qu‚Äôelle en re√ßoit et disparait apr√®s.

- Il y aura √©galement l‚Äôajout de cartes qui auront un effet imm√©diat et qui se d√©placeront directement dans le ¬´ graveyard ¬ª par la suite (On n‚Äôattend pas la fin du tour).
    - Lightning Strike X, fait X d√©g√¢ts au joueur adverse. (Attention, c‚Äôest possible que la partie se termine)
    - Earthquake X, fait X d√©g√¢ts √† TOUTES les cartes en jeu.
    - Magical Hammer X, fait X d√©g√¢ts √† une carte adverse.
</details>

<details>
<summary>Classement ELO et Matchmaking</summary>

Pour faire jouer des joueurs avec des forces comparables et avoir un classement des joueurs, on utilisera le syst√®me ELO.
C'est un syst√®me tr√®s connu qui permet entre autres de faire le classement des joueurs d'√©checs.


D√©tails de notre syst√®me ELO:
    - Les joueurs commencent avec un score de 1000
    - Apr√®s chaque match on utilise la m√©thode de calcul de ELO (fournie plus bas) qui va mettre √† jour le score des 2 joueurs.
      - Le joueur qui a gagn√© voit son score augment√©
      - Le joueur qui a perdu voit son score diminu√©
  
- Afficher le changement de ELO apr√®s chaque Match (Dans le menu de Victoire/D√©faite)
- Ajouter une menu avec 2 tableaux de classement
  - Les 8 meilleurs joueurs
    - Si le joueur actif est un des 8 meilleurs, l'afficher avec une autre couleur
  - Les joueurs pr√™t du joueur courrant (afficher 4 au-dessus et 3 en-dessous).
    - Montrer le joueur actif avec une autre couleur
    - Cas sp√©cial : si l‚Äôutilisateur est un des 5 meilleurs joueurs, le tableau montre √©galement les 8 meilleures joueurs.
- Ajouter un seed avec au moins 10 joueurs qui ont des scores ELO diff√©rents
- Utiliser une **bacground task** pour faire le **matchmaking** qui va s'ex√©cuter chaque seconde
  - Logique du matchmaking:
    - Avec une liste de joueurs qui attend de d√©marrer une partie
    - On passe la liste de joueurs. Pour chaque joueur, on trouve le joueur qui a l'ELO le plus similaire.
      -  On v√©rifit si diff√©rence d'ELO est inf√©rieur au nombre de secondes d'attentes du joueur qui attend depuis le plus longtemps multipli√© par une constante (3 devrait donner un bon r√©sultat). Si c'est le cas, on ajoute la paire √† une liste pour d√©marrer le match.
    - On augmente le nombre de secondes d'attente des joueurs qui attendent encore
    - Une fois que tout √† √©t√© √©valu√©, la logique retourne la liste des paires de joueurs
    - La task d√©marre ensuite les matchs pour ces joueurs
  - Mettre la fonctionnalit√© de ranking dans un service et √©crire des tests unitaires
    - V√©rifier qu'il retourne une paire si on a 2 joueurs avec des ELOs assez proche
    - V√©rifier qu'il retroune une liste vide si les 2 joueurs ont des ELOs trop diff√©rents pour le temps qui a pass√©.
    - V√©rifier qu'il fait retourne les bonnes paires avec un groupe de 6 joueurs et qu'il retourne 2 paires avec les joueurs les plus proches, mais qu'il ne retourne pas la derni√®re paire qui a des ELOs trop √©loign√©.

Note: Pour ceux qui aime les d√©tails, on va garder l'algorithme de s√©lection des paires de joueurs assez simple et donner l'avantage aux joueurs qui attendent depuis le plus longtemps!
Donc dans le cas ou les joueurs attendent dans cet ordre: 1000, 1005, 1007, 994. On va chercher l'ELO le plus pr√®s de 1000 en premier, trouver 1005 (+5) et ensuite faire la paire 1007 et 994. M√™me si on pourrait faire 2 meilleures paires: 994 et 1000 et 1005 et 1007. (Mais si vous voulez mettre en place un algorithme plus performant, vous √™tes les bienvenues!!)



Apr√®s chaque match, utiliser cette m√©thode pour calculer le nouveau score des 2 joueurs.

```csharp
public class EloCalculator
{
    public enum GameOutcome
    {
        Win = 1,
        Loss = 0
    }

    public static void CalculateELO(ref int p1Rating, ref int p2Rating, GameOutcome p1Outcome)
    {
        int eloK = 32;

        double expectation = ExpectationToWin(p1Rating, p2Rating);
        int delta = (int)(eloK * ((int)p1Outcome - expectation));

        p1Rating += delta;
        p2Rating -= delta;
    }

    private static double ExpectationToWin(int p1Rating, int p2Rating)
    {
        return 1 / (1 + Math.Pow(10, (p2Rating - p1Rating) / 400.0));
    }
}
```

**Note:** Sans expliquer le d√©tails des maths, le syst√®me augmente les points du gagnant et diminue celui du perdant. Si le gagnant avait un grand score par rapport au perdant, le changement est faible (On s'attendait √† ce qu'il gagne). Mais si le gagnant avait un score plus petit, le changement est plus important en proportion de la diff√©rence.
</details>

<details>
<summary>Statistiques des joueurs</summary>
- Un joueur aura la possibilit√© de voir des statistiques √† propos de ses decks ou de l‚Äôensemble de ses cartes
    - Il pourra voir le **nombre de victoire et d√©faites avec ce deck (ou g√©n√©ral)**
    - La distribution des cartes (En utilisant des graphs similaires):
        - Co√ªt
        - Raret√©
        - Attaque et d√©fense
- Vous pouvez utiliser la technologie de graph que vous pr√©f√©rez, mais voici une proposition : https://canvasjs.com/angular-charts/pie-chart-index-data-label/ 

#### Lorsqu‚Äôon affiche l‚Äôensemble des cartes

|![alt text](/img/tps/tp3/image-1.png)|
|-|

#### Lorsque l‚Äôon s√©lectionne un deck

|![alt text](/img/tps/tp3/image-2.png)|
|-|
</details>

<details>
<summary>Discussion et mode spectateur</summary>
- Chat dans un menu sur le c√¥t√© avec les messages et la liste des gens pr√©sent (Les spectateurs peuvent √©crire aussi, mais les joueurs peuvent les banir de la partie)
  - On peut √©galement faire Mute, pour ne plus affiche les messages d'un joueur ou spectateur sur notre client pour cette partie
- Un nouveau mean avec la liste des parties actives avec l'option de les regarder (Si on n'est pas un joueur)
- Afficher un message dans l'√©cran lorsqu'un spectacteur se joint √† une partie (Afficher son nom ou email)
- Am√©liorer la jouabilit√© en affichant un countour de couleur autour des cartes que l'on peut jouer (si le joueur a assez de Mana)
  - (Cliquer sur une autre carte qui n'en a pas assez ne devrait pas faire d'appel au serveur!)
</details>


## Partie Commune Finale (4%)
- Faire le merge des diff√©rentes partie
- Faire le d√©ploiement
- Fixer le probl√®me de mise √† jour du match (d√©tails √† venir!)

## Grille de correction
- 11% de la note pour l‚Äô√©valuation individuelle (voir le document sur la correction individuelle)
- 9% de la note pour l‚Äô√©valuation de groupe
    -	5% pour la premi√®re remise
    -	4% pour la remise final


<!--
## R√©f√©rence pour la remise finale en √©quipe

Une r√©f√©rence pour voir un client et un serveur fonctionnels.

- üîó[Client](https://wonderful-tree-0ccc8c610.4.azurestaticapps.net/)

:::info
Vous pouvez simplement utiliser register pour ajouter vos propres joueurs
:::

- üîó[Serveur](https://supercartesinfiniesTP2.azurewebsites.net/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

:::danger
C'est possible que les exemples ne fonctionnent pas bien selon vos options de cookies. Nous allons les regarder en classe. Pour le truc: [Cookies](/info/Trucs#pour-accepter-les-cookies-third-parties)
:::
-->