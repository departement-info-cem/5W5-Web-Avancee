# TP3 (Super suite de Super Cartes Infinies)

## Le projet
Ajouter des fonctionnalit√©s au jeu de cartes d√©velopp√© lors du Sprint 2.

:::info
Vous devez choisir une des t√¢ches suivantes qui sera √©valuer de fa√ßon individuelle. Vous devez √©crire vous-m√™me le code, mais vous pouvez collaborer avec vos coll√®gues.
:::

### Les t√¢ches individuelles
:::warning
La t√¢che de pouvoirs suppl√©mentaires doit √™tre fait par un autre √©tudiant que celui qui a fait la logique de jeu au TP2
:::
- **\[Obligatoire\]** Pouvoirs suppl√©mentaires et cartes de sort
- **\[Obligatoire\]** Classement et matchmaking
- Discussion et mode spectateur
- Statistiques

### Contraintes
- Le travail doit √™tre effectu√© en √©quipes de 3 ou 4.
- Vous devez utiliser **Git/GitHub**.
- Vous devez utiliser **DevOps** pour la gestion des t√¢ches ET utiliser les **sprints**.
- L'√©tudiant qui a fait la logique de jeu au **TP2** ne peut pas faire les pouvoirs suppl√©mentaires pour ce TP

### Les √©tapes et √©valuations
Il y a 2 √©valuations, mais il est fortement recommand√© de terminer les t√¢ches individuelles **au moins une semaine** avant la remise d'√©quipe :
- Premier livrable d'√©quipe (Premi√®re √©valuation)
- Fonctionnalit√©s individuelles
- Merge et derni√®re fonctionnalit√© (Deuxi√®me √©valuation)

## Premier livrable d'√©quipe (4%)
- Comme on va travailler en Test Driven Development (TDD). Il faut ajouter au moins un test complet pour chacun des nouveaux pouvoirs. (Voir la premi√®re t√¢che individuelle)
    - Il va falloir faire quelques ajouts au code pour pouvoir √©crire les tests. Comme une m√©thode HasStatus() et GetStatusValue().
- Prot√®ger la branche de d√©veloppement avec des tests unitaires automatiques et au moins un review pour le Pull Request. (L'appliquer sur la branche o√π les diff√©rentes parties individuelles vont √™tre merg√©es)

## T√¢ches individuelles (12%)

<details>
<summary>Pouvoirs suppl√©mentaires</summary>

    Un premier pouvoir "normal":    
    - **Chaos**, inverse l'attaque et la d√©fense de toutes les cartes en jeu. Il se produit avant que la carte attaque. Attention, les cartes avec 0 d'attaques doivent mourrir tout de suite.
    
    Des pouvoirs qui vont **modifier un √©tat**:
    - **Poison X**, qui ajoute une valeur de poison √† la carte attaqu√©e. Le poison diminue ensuite la vie d‚Äôune carte de la valeur du poison √† la fin de son activation. Si une carte a d√©j√† une valeur de poison et qu‚Äôelle est √† nouveau attaqu√©e, la valeur de poison est augment√©e.
    - **Stunned X**, qui emp√™che une carte d‚Äôagir pendant son activation durant X tours. (Mais elle re√ßoit quand m√™me les d√©g√¢ts de poison!)
        - Tester que le status "stunned" est pr√©sent avec la valeur X ET que la carte avec le status "stunned" n'est pas activ√©e √† son tour et que le status "stunned" a diminu√© de 1.
    
    - Il faut ajouter un syst√®me g√©n√©rique de gestion d'√©tat. Un PlayableCard a donc une liste de PlayableCardStatus. Un PlayableCardStatus a une valeur et un Status. Et la classe Status a un Id, un nom, une descrption et un icone. (Bref, c'est similaire √† un pouvoir (Power), mais pour les √©tats.). Il faut ajouter un Status Poisoned et Stunned. Il faut √©galement ajouter des m√©thodes HasStatus, AddStatusValue et GetStatusValue (Encore une fois, similaire √† la gestion de pouvoirs).
    - Ajouter des tests unitaires pour les nouvelles m√©thodes de gestion de status pour vous assurer qu'elles fonctionnent bien avant de commencer a travailler sur les pouvoirs.

    Il y aura √©galement l‚Äôajout de cartes de sorts (Spells) qui auront un effet imm√©diat et qui se d√©placeront directement dans le ¬´ graveyard ¬ª apr√®s avoir √©t√© jou√© (Il faut animer les pouvoirs avant de d√©placer la carte vers le Graveyard):
    - **Earthquake X**, fait X d√©g√¢ts √† TOUTES les cartes en jeu (m√™me les n√¥tres!).
    - **Random Pain**, fait 1 √† 6 de d√©g√¢ts √† une carte adverse (au hazard).

    Ajouter √©galement **un pouvoir √† votre choix** (Valider avec le Prof!) (vous pouvez ajouter un sort)

    Il faut avoir un seed avec **chacun des nouveaux pouvoirs** sur **au moins une des cartes de d√©part** (Vous pouvez ajouter de nouvelles cartes de d√©parts)
</details>

<details>
<summary>Classement ELO et Matchmaking</summary>

Pour faire jouer des joueurs avec des forces comparables et avoir un classement des joueurs, on utilisera le syst√®me ELO.
C'est un syst√®me tr√®s connu qui permet entre autres de faire le classement des joueurs d'√©checs.

D√©tails de notre syst√®me ELO:
    - Les joueurs commencent avec un score de 1000
    - Apr√®s chaque match on utilise la m√©thode de calcul de ELO (fournie plus bas) qui va mettre √† jour le score des 2 joueurs.
      - Le joueur qui a **gagn√©** voit son score ELO **augment√©**
      - Le joueur qui a **perdu** voit son score ELO **diminu√©**
  
- Afficher le changement de ELO apr√®s chaque Match (Dans le menu de Victoire/D√©faite)
- Afficher le ELO du joueur √† c√¥t√© de son argent sur le client
- Utiliser une **background task** pour faire le **matchmaking** qui va s'ex√©cuter **chaque seconde**
  - Contient une liste d'info des players (PlayerInfo) qui attendent pr√©sentement (avec leur userId, ELO, temps d'attente)
  - Logique du service de matchmaking:
    - Faire une copie de la liste et appeler GeneratePairs (avec le pseudo code juste apr√®s)
    - D√©marrer un match pour chaque paire de joueurs
    - Retirer les paires de la liste de players qui attendent
    - On augmente le nombre de secondes d'attente des joueurs qui attendent encore

```
// Passer une COPIE de l'information sur les players (Car on va retirer les √©l√©ments de la liste, m√™me si le player n'est pas mis dans une paire)
List<PairOfPlayers> GeneratePairs(List<PlayerInfo> playerInfos){
    pairs = new List<PairOfPlayers>

    // Tant qu'il y a des joueurs √† mettre en pair
    while(playerInfos.Count > 0)
        playerInfo = playersInfos[0]
        playersInfo.RemoveFirst()
        smallestELODifference = int.MAXVALUE
        index = -1
        for(i = 0; i < playersInfo.Count; i++)
            pi = playersInfo[i]
            difference = valeurAbsolue(pi.ELO - playerInfo.ELO)
            if difference < playerInfo.attente * CONSTANTE
                if(difference < smallestELODifference)
                    smallestELODifference = difference
                    index = i
        
        // Si on a trouv√© une paire
        if index >= 0
            playerInfo2 = playersInfos[index]
            playersInfo.RemoveAt(index)
            pairs.Add(new PairOfPlayers(playerInfo, playerInfo2))
        // Sinon, c'est pas grave, on a retir√© l'√©l√©ment de la liste et on va √©valuer le prochain


}
```
:::warning
Il y a une autre raison pourquoi on veut faire une copie de la liste avant de la passer √† la m√©thode GeneratePairs. C'est qu'on veut se prot√©ger du cas o√π un nouveau joueur s'ajouterait pendant que l'on fait les paires et que l'on risquerait d'avoir des probl√®mes avec notre logique.
:::

Pour faire une copie d'une liste, on peut simplement faire:
```csharp
var copy = new List<PlayerInfo>(listOriginale);
```

**Note:** Pour ceux qui aime les d√©tails, on va garder l'algorithme de s√©lection des paires de joueurs assez simple et donner l'avantage aux joueurs qui attendent depuis le plus longtemps!
Donc dans le cas ou les joueurs attendent dans cet ordre: 1000, 1005, 1007, 994. On va chercher l'ELO le plus pr√®s de 1000 en premier, trouver 1005 (+5) et ensuite faire la paire 994 et 1007(+13). M√™me si on pourrait faire 2 meilleures paires: 994 et 1000 (+6) et 1005 et 1007 (+2). (Mais si vous voulez mettre en place un algorithme plus performant, vous √™tes les bienvenues!!) 
  
  - Mettre la fonctionnalit√© de ranking dans un service et √©crire des tests unitaires
    - V√©rifier qu'il retourne une paire si on a 2 joueurs avec des ELOs assez proche
    - V√©rifier qu'il retroune une liste vide si les 2 joueurs ont des ELOs trop diff√©rents pour le temps qui a pass√©.
    - V√©rifier qu'il fait retourne les bonnes paires avec un groupe de 6 joueurs et qu'il retourne 2 paires avec les joueurs les plus proches, mais qu'il ne retourne pas la derni√®re paire qui a des ELOs trop √©loign√©.

Dans EndMatchEvent, utiliser cette m√©thode pour calculer le nouveau score des 2 joueurs.

```csharp
public class EloCalculator
{
    public enum GameOutcome
    {
        Win = 1,
        Loss = 0
    }

    public static void CalculateELO(ref int p1Rating, ref int p2Rating, GameOutcome p1Outcome)
    {
        int eloK = 32;

        double expectation = ExpectationToWin(p1Rating, p2Rating);
        int delta = (int)(eloK * ((int)p1Outcome - expectation));

        p1Rating += delta;
        p2Rating -= delta;
    }

    private static double ExpectationToWin(int p1Rating, int p2Rating)
    {
        return 1 / (1 + Math.Pow(10, (p2Rating - p1Rating) / 400.0));
    }
}
```

**Note:** Sans expliquer le d√©tails des maths, le syst√®me augmente les points du gagnant et diminue celui du perdant. Si le gagnant avait un grand score par rapport au perdant, le changement est faible (On s'attendait √† ce qu'il gagne). Mais si le gagnant avait un score plus petit, le changement est plus important en proportion de la diff√©rence.
</details>

<details>
<summary>Discussion et mode spectateur</summary>
- Chat dans un menu sur le c√¥t√© avec les messages et la liste des gens pr√©sent (joueurs et spectateurs)
  - Les joueurs et spectateurs peuvent √©crire de messages et on voit qui a √©crit chacun des message
  - Si un spectateur est bani, il est sortie de la partie et ne peut plus la joindre (On ne peut pas banir un joueur)
  - On peut √©galement faire Mute, pour ne plus afficher les messages d'un joueur ou spectateur sur notre client pour cette partie

|![alt text](image-1.png)|
|-|

- Un nouveau menu avec la liste des parties actives avec l'option de les regarder (Si on n'est pas un joueur de cette partie)

|![alt text](image.png)|
|-|

    - Si il n'y a aucune partie courrante, afficher un texte qui le mentionne.
    - Afficher le nom des 2 joueurs dans le menu des parties actives
    - Il faut ajouter l'option de joindre la partie comme spectateur dans le Hub. La logique devrait ressembler au JoinMatch d'une partie d√©j√† existante.
    - Lorsque l'on joint une partie, on ne peut PAS voir les cartes dans les mains des 2 joueurs, on voit seulement le dos des cartres, comme pour l'adversaire dans un match normal.
    - Il n'y a √©videmment pas la possibilit√© de jouer de carte, ni de terminer un tour ou d'abandonner.
</details>

<details>
<summary>Statistiques des joueurs</summary>
- Un joueur aura la possibilit√© de voir des statistiques √† propos de ses decks ou de l‚Äôensemble de ses cartes
    - Il pourra voir le **nombre de victoire et d√©faites avec ce deck (ou g√©n√©ral)**
    - La distribution des cartes (En utilisant des graphs similaires):
        - Co√ªt
        - Raret√©
        - Attaque et d√©fense
- Il faut ajouter le nombre de victoires et de d√©faites sur Player et le mettre √† jour √† la fin de chaque match
- Il faut √©galement ajouter le nombre de victoires et de d√©faites sur Deck et le mettre √† jour √† la fin de chaque match
- Vous pouvez utiliser la technologie de graph que vous pr√©f√©rez, mais voici une proposition : https://canvasjs.com/angular-charts/pie-chart-index-data-label/
- Si vous utilisez cette technologie, une fois que vous avez r√©ussi √† int√©grer des graphs avec des valeurs hardcod√©s, regardez cette exemple pour comprendre comment afficher vos donn√©es dynamiquement: https://canvasjs.com/angular-charts/dynamic-live-column-chart/
:::warning
Notre situation est diff√©rente de celle de l'exemple, mais l'important c'est de comprendre la partie avec getChartInstance et UpdateChart.
:::
:::warning
Dans votre cas, pas besoin de mettre le data √† jour chaque seconde avec un timeout comme dans cet exemple!
:::
- Il faut avoir un seed avec un minimum de 20 cartes diff√©rentes avec des valeurs vari√©es √† fin de pouvoir bien voir les statistiques des cartes.


#### Lorsqu‚Äôon affiche l‚Äôensemble des cartes

|![alt text](/img/tps/tp3/image-1.png)|
|-|

#### Lorsque l‚Äôon s√©lectionne un deck

|![alt text](/img/tps/tp3/image-2.png)|
|-|
</details>


## Partie Commune Finale (4%)
- Faire le merge des diff√©rentes partie
- Faire le d√©ploiement
    - D√©ployer Angular
    - D√©ployer WebAPI
    - (**PAS** n√©cessaire de d√©ployer le serveur MVC)
- Fixer [le probl√®me de mise √† jour du match](/info/NgZone)

## Bonus d'√©quipe (2%)
- Modifier le client pour:
        - G√©rer les nouveaux pouvoirs, incluant les sorts
        - Afficher les ic√¥nes des nouveaux pouvoirs et les animer pendant les combats
        - Afficher les status d'une carte (poisoned) ou (stunned)

## Grille de correction
- 12% de la note pour l‚Äô√©valuation individuelle (voir le document sur la correction individuelle)
    - 2% pour l'utilisation d'Azure DevOps Boards
    - 10% pour le code et les fonctionnalit√©s
- 8% de la note pour l‚Äô√©valuation de groupe
    -	4% pour la premi√®re remise
    -	4% pour la remise final
    -   2% pour le bonus

<!--
## R√©f√©rence pour la remise finale en √©quipe

Une r√©f√©rence pour voir un client et un serveur fonctionnels.

- üîó[Client](https://wonderful-tree-0ccc8c610.4.azurestaticapps.net/)

:::info
Vous pouvez simplement utiliser register pour ajouter vos propres joueurs
:::

- üîó[Serveur](https://supercartesinfiniesTP2.azurewebsites.net/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

-->
