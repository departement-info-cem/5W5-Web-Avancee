# TP3 (Super suite de Super Cartes Infinies)

## Le projet
Ajouter des fonctionnalit√©s au jeu de cartes d√©velopp√© lors du Sprint 2.

:::info
Vous devez choisir une des t√¢ches suivantes qui sera √©valuer de fa√ßon individuelle. Vous devez √©crire vous-m√™me le code, mais vous pouvez collaborer avec vos coll√®gues.
:::

### Les t√¢ches individuelles
:::warning
La t√¢che de pouvoirs suppl√©mentaires doit √™tre fait par un autre √©tudiant que celui qui a fait la logique de jeu au TP2
:::
- **\[Obligatoire\]** Pouvoirs suppl√©mentaires et cartes de sort
- **\[Obligatoire\]** Classement et matchmaking
- Discussion et mode spectateur
- Statistiques

### Contraintes
- Le travail doit √™tre effectu√© en √©quipes de 3 ou 4.
- Vous devez utiliser **Git/GitHub**.
- Vous devez utiliser **DevOps** pour la gestion des t√¢ches ET utiliser les **sprints**.

### Les √©tapes et √©valuations
Il y a 2 √©valuations, mais il est fortement recommand√© de terminer les t√¢ches individuelles **au moins une semaine** avant la remise d'√©quipe :
- Premier livrable d'√©quipe (Premi√®re √©valuation)
- Fonctionnalit√©s individuelles
- Merge et derni√®re fonctionnalit√© (Deuxi√®me √©valuation)

## Premier livrable d'√©quipe (5%)
- Comme on va travailler en Test Driven Development (TDD). Il faut ajouter au moins un test complet pour chacun des nouveaux pouvoirs. (Voir la premi√®re t√¢che individuelle)
    - Il va falloir faire quelques ajouts au code pour pouvoir √©crire les tests. Comme une m√©thode HasStatus() et GetStatusValue().
- Il faut ordonner les cartes sur le BattleField en [utilisant un Index](/info/DataOrder)
- Prot√®ger la branche de d√©veloppement avec des tests unitaires automatiques et au moins un review pour le Pull Request. (L'appliquer sur la branche o√π les diff√©rentes parties individuelles vont √™tre merg√©es)
- Cr√©er les t√¢ches dans DevOps

## T√¢ches individuelles (11%)

<details>
<summary>Pouvoirs suppl√©mentaires</summary>
    - **Boost Attack X**, qui augmente l'attaque des cartes en jeu du joueur. (PlayableCard va devoir avoir sa propre propri√©t√© Attack)
    - **Chaos**, inverse l'attaque et la d√©fense de toutes les cartes en jeu. Il se produit avant que la carte attaque.
    - **Resurect**, ram√®ne une carte du Graveyard du joueur en jeu. La carte ramen√© en jeu n'attaque pas tout de suite et a seulement 1 de Health. (La carte est choisi au hazard).
        - Ne peut pas ramener un sort! (voir prochains pouvoirs)

    Il y aura l‚Äôajout de pouvoirs pour les cartes qui vont **modifier un √©tat**:
    - **Poison X**, qui ajoute une valeur de poison √† la carte attaqu√©e. Le poison diminue ensuite la vie d‚Äôune carte de la valeur du poison √† la fin de son activation. Si une carte a d√©j√† une valeur de poison et qu‚Äôelle est √† nouveau attaqu√©e, la valeur de poison est augment√©e.
    - **Stunned X**, qui emp√™che une carte d‚Äôagir pendant son activation durant X tours. (Mais elle re√ßoit quand m√™me les d√©g√¢ts de poison!)
        - Tester que le status "stunned" est pr√©sent avec la valeur X ET que la carte avec le status "stunned" n'est pas activ√©e √† son tour et que le status "stunned" a diminu√© de 1.
        
    
    Il y aura √©galement l‚Äôajout de cartes de sorts (Spells) qui auront un effet imm√©diat et qui se d√©placeront directement dans le ¬´ graveyard ¬ª apr√®s avoir √©t√© jou√© (Il faut animer les pouvoirs avant de d√©placer la carte vers le Graveyard):
    - **Lightning Strike X**, fait X d√©g√¢ts au joueur adverse. (Attention, c‚Äôest possible que la partie se termine)
    - **Earthquake X**, fait X d√©g√¢ts √† TOUTES les cartes en jeu (m√™me les n√¥tres!).
    - **Random Pain X**, fait 1 √† 6 de d√©g√¢ts √† une carte adverse (au hazard).

    - Il faut ajouter un syst√®me g√©n√©rique de gestion d'√©tat. Un PlayableCard a donc une liste de PlayableCardStatus. Un PlayableCardStatus a une valeur et un Status. Et la classe Status a un Id, un nom, une descrption et un icone. (Bref, c'est similaire √† un pouvoir (Power), mais pour les √©tats.). Il faut ajouter un Status Poisoned et Stunned. Il faut √©galement ajouter une m√©thode HasStatus et GetStatusValue (Encore une fois, similaire √† la gestion de pouvoirs).

    - Il faut √©galement modifier le client pour:
        - Bien afficher les sorts quand ils sont jou√©s
        - Afficher les status d'une carte (poisoned) ou (stunned)
        - Afficher les ic√¥nes des pouvoirs et animer les pouvoirs correctement pour que l'on puisse voir ce qui arrive

    - Il faut avoir un seed avec chacun des pouvoirs sur au moins une carte
</details>

<details>
<summary>Classement ELO et Matchmaking</summary>

Pour faire jouer des joueurs avec des forces comparables et avoir un classement des joueurs, on utilisera le syst√®me ELO.
C'est un syst√®me tr√®s connu qui permet entre autres de faire le classement des joueurs d'√©checs.

D√©tails de notre syst√®me ELO:
    - Les joueurs commencent avec un score de 1000
    - Apr√®s chaque match on utilise la m√©thode de calcul de ELO (fournie plus bas) qui va mettre √† jour le score des 2 joueurs.
      - Le joueur qui a **gagn√©** voit son score ELO **augment√©**
      - Le joueur qui a **perdu** voit son score ELO **diminu√©**
  
- Afficher le changement de ELO apr√®s chaque Match (Dans le menu de Victoire/D√©faite)
- Ajouter un menu avec 2 tableaux de classement
  - Les 8 meilleurs joueurs
    - Si le joueur actif est un des 8 meilleurs, l'afficher avec une autre couleur
  - Les joueurs pr√™ts du joueur courant (afficher 4 au-dessus et 3 en-dessous).
    - Montrer le joueur actif avec une autre couleur
    - Cas sp√©cial : si l‚Äôutilisateur est un des 5 meilleurs joueurs, le tableau montre √©galement les 8 meilleures joueurs. (Pas seulement 3 joueurs en dessous)
- Ajouter un **seed** avec **au moins 10 joueurs** qui ont des **scores ELO diff√©rents**
- Utiliser une **bacground task** pour faire le **matchmaking** qui va s'ex√©cuter **chaque seconde**
  - Contient une liste d'info des players (PlayerInfo) qui attendent pr√©sentement (avec leur userId, ELO, temps d'attente)
  - Logique du service de matchmaking:
    - Faire une copie de la liste et appeler GeneratePairs (avec le pseudo code juste apr√®s)
    - D√©mmarer un match pour chaque paire de joueurs
    - Retirer les paires de la liste de players qui attendent
    - On augmente le nombre de secondes d'attente des joueurs qui attendent encore

```
// Passer une COPIE de l'information sur les players (Car on va retirer les √©l√©ments de la liste, m√™me si le player n'est pas mis dans une paire)
List<PairOfPlayers> GeneratePairs(List<PlayerInfo> playerInfos){
    pairs = new List<PairOfPlayers>

    // Tant qu'il y a des joueurs √† mettre en pair
    while(playerInfos.Count > 0)
        playerInfo = playersInfos[0]
        playersInfo.RemoveFirst()
        smallestELODifference = int.MAXVALUE
        index = -1
        for(i = 0; i < playersInfo.Count; i++)
            pi = playersInfo[i]
            difference = valeurAbsolue(pi.ELO - playerInfo.ELO)
            if difference < playerInfo.attente * CONSTANTE
                if(difference < smallestELODifference)
                    smallestELODifference = difference
                    index = i
        
        // Si on a trouv√© une paire
        if index >= 0
            playerInfo2 = playersInfos[index]
            playersInfo.RemoveAt(index)
            pairs.Add(new PairOfPlayers(playerInfo, playerInfo2))
        // Sinon, c'est pas grave, on a retir√© l'√©l√©ment de la liste et on va √©valuer le prochain


}
```
**Note:** Pour ceux qui aime les d√©tails, on va garder l'algorithme de s√©lection des paires de joueurs assez simple et donner l'avantage aux joueurs qui attendent depuis le plus longtemps!
Donc dans le cas ou les joueurs attendent dans cet ordre: 1000, 1005, 1007, 994. On va chercher l'ELO le plus pr√®s de 1000 en premier, trouver 1005 (+5) et ensuite faire la paire 994 et 1007(+13). M√™me si on pourrait faire 2 meilleures paires: 994 et 1000 (+6) et 1005 et 1007 (+2). (Mais si vous voulez mettre en place un algorithme plus performant, vous √™tes les bienvenues!!) 
  
  - Mettre la fonctionnalit√© de ranking dans un service et √©crire des tests unitaires
    - V√©rifier qu'il retourne une paire si on a 2 joueurs avec des ELOs assez proche
    - V√©rifier qu'il retroune une liste vide si les 2 joueurs ont des ELOs trop diff√©rents pour le temps qui a pass√©.
    - V√©rifier qu'il fait retourne les bonnes paires avec un groupe de 6 joueurs et qu'il retourne 2 paires avec les joueurs les plus proches, mais qu'il ne retourne pas la derni√®re paire qui a des ELOs trop √©loign√©.

Apr√®s chaque match, utiliser cette m√©thode pour calculer le nouveau score des 2 joueurs.

```csharp
public class EloCalculator
{
    public enum GameOutcome
    {
        Win = 1,
        Loss = 0
    }

    public static void CalculateELO(ref int p1Rating, ref int p2Rating, GameOutcome p1Outcome)
    {
        int eloK = 32;

        double expectation = ExpectationToWin(p1Rating, p2Rating);
        int delta = (int)(eloK * ((int)p1Outcome - expectation));

        p1Rating += delta;
        p2Rating -= delta;
    }

    private static double ExpectationToWin(int p1Rating, int p2Rating)
    {
        return 1 / (1 + Math.Pow(10, (p2Rating - p1Rating) / 400.0));
    }
}
```

**Note:** Sans expliquer le d√©tails des maths, le syst√®me augmente les points du gagnant et diminue celui du perdant. Si le gagnant avait un grand score par rapport au perdant, le changement est faible (On s'attendait √† ce qu'il gagne). Mais si le gagnant avait un score plus petit, le changement est plus important en proportion de la diff√©rence.
</details>

<details>
<summary>Discussion et mode spectateur</summary>
- Chat dans un menu sur le c√¥t√© avec les messages et la liste des gens pr√©sent (Les spectateurs peuvent √©crire aussi, mais les joueurs peuvent les banir de la partie)
  - On peut √©galement faire Mute, pour ne plus affiche les messages d'un joueur ou spectateur sur notre client pour cette partie
  - On voit qui a √©crit chacun des message
- Un nouveau menu avec la liste des parties actives avec l'option de les regarder (Si on n'est pas un joueur de cette partie)
    - Si il n'y a aucune partie courrante, afficher un texte qui le mentionne.
    - Afficher le nom des 2 joueurs dans le menu des parties actives
    - Lorsque l'on joint une partie, on ne peut PAS voir les cartes des 2 joueurs. On voit seulement les cartes une fois qu'elles sont en jeu!
    - Il n'y a √©videmment pas la possibilit√© de jouer de carte, ni de terminer un tour ou d'abandonner.
    - On peut appuyer sur un bouton pour changer de perspective (voir le jeu comme le joueur B au lieu du joueur A)
- Afficher un message dans l'√©cran des joueurs et spectateurs lorsqu'un spectacteur se joint √† une partie (Afficher son nom ou email)
- Am√©liorer la jouabilit√© en affichant un countour de couleur autour des cartes que l'on peut jouer (si le joueur a assez de Mana)
  - (Cliquer sur une autre carte qui n'en a pas assez ne devrait pas faire d'appel au serveur!)
</details>

<details>
<summary>Statistiques des joueurs</summary>
- Un joueur aura la possibilit√© de voir des statistiques √† propos de ses decks ou de l‚Äôensemble de ses cartes
    - Il pourra voir le **nombre de victoire et d√©faites avec ce deck (ou g√©n√©ral)**
    - La distribution des cartes (En utilisant des graphs similaires):
        - Co√ªt
        - Raret√©
        - Attaque et d√©fense
- Vous pouvez utiliser la technologie de graph que vous pr√©f√©rez, mais voici une proposition : https://canvasjs.com/angular-charts/pie-chart-index-data-label/ 
- Il faut avoir un seed avec un minimum de 20 cartes diff√©rentes avec des valeurs vari√©es √† fin de pouvoir bien voir les statistiques des cartes.

#### Lorsqu‚Äôon affiche l‚Äôensemble des cartes

|![alt text](/img/tps/tp3/image-1.png)|
|-|

#### Lorsque l‚Äôon s√©lectionne un deck

|![alt text](/img/tps/tp3/image-2.png)|
|-|
</details>




## Partie Commune Finale (4%)
- Faire le merge des diff√©rentes partie
- Faire le d√©ploiement
- Fixer le probl√®me de mise √† jour du match (d√©tails √† venir!)

## Grille de correction
- 11% de la note pour l‚Äô√©valuation individuelle (voir le document sur la correction individuelle)
- 9% de la note pour l‚Äô√©valuation de groupe
    -	5% pour la premi√®re remise
    -	4% pour la remise final


<!--
## R√©f√©rence pour la remise finale en √©quipe

Une r√©f√©rence pour voir un client et un serveur fonctionnels.

- üîó[Client](https://wonderful-tree-0ccc8c610.4.azurestaticapps.net/)

:::info
Vous pouvez simplement utiliser register pour ajouter vos propres joueurs
:::

- üîó[Serveur](https://supercartesinfiniesTP2.azurewebsites.net/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

:::danger
C'est possible que les exemples ne fonctionnent pas bien selon vos options de cookies. Nous allons les regarder en classe. Pour le truc: [Cookies](/info/Trucs#pour-accepter-les-cookies-third-parties)
:::
-->