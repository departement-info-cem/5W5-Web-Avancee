# TP2 (Suite de Super Cartes Infinies)

## L’application

## Grandes lignes:
Ajout des habiletés:
    - Modèle: (Ability/AbilityCard)
    - Pouvoir associer les habiletés aux cartes (MVC)
    - Logique pour connaitre la valeur d'un habileté pour un CardInstance
    - Voir les habiletés sur les cards
    - Pouvoir voir le détails d'une carte avec un appel AJAX
    - Animer les habiletés sur le board

Logique de jeu:
    - Faire passer les tests de TDD (Règles de jeu)
    - Écrire un test pour notre pouvoir au choix

Decks:
    - Modèle: (Deck/DeckCard)
    - Ajouter la possibilité de créer des decks
    - Avoir un deck par défaut (créer pendant le register)
    - Pouvoir sélectionner le deck actif
    - Max de cartes dans un deck (avec config MVC)
    - Ajout d'un service pour la gestion des decks (Tests unitaires)

Magasin avec paquets de cartes:
    - Modèle: (Pack et PackRarityStats)
    - Monnaie virtuel (gagné dans le jeu Victoire/défaite)
    - Tâche MVC pour le prix des cartes
    - Tâche MVC pour la conception des decks
    - Ajout d'un service pour obtenir les cartes du magasin
    - Ajout d'un service pour l'achat et la vente de cartes (Tests unitaires)
    - Ajout d'un service pour l'achat de paquets (Tests unitaires)
    
    




## TODO:
- MOI: Obfusquer le code

- Ajouter un diagramme de classes comme livrable
- Demander des tests unitaires pour les services
- Gestion des erreurs de cookies
- Parler des sprints
- Montrer des animations de base pour le TP2

### Objectifs : 
Ajouter des fonctionnalités au jeu de cartes développé lors du Sprint 1.

:::info
	Si vous n’avez pas réussi à compléter une partie du TP1, regardez avec votre enseignant pour savoir comment faire le TP2 sans devoir travailler en double.
:::

### Les règles de jeu :
- Chaque carte prend un tour avec d’être activé (Ce que l’on appelle habituellement le « summoning sickness »).
    - Cependant, elle peut déjà se défendre dès qu’elle est en jeu.

- On peut jouer plusieurs cartes par tour, selon leur coût en « Mana ».
    - Chaque carte à un coût en Mana différent. On peut jouer la carte si le joueur en a assez et après on réduit son mana du coût de la carte.
    - Lorsque le Mana n’est pas utilisé, il s’accumule pour le tour d’après.
    - Lorsqu'un joueur clique sur terminer, les cartes qui sont déjà en jeu doivent être "activé"
 
- Ajouter des habilités à certaines cartes. On pourra donc associer une liste d’habiletés à nos cartes en MVC. (On parle ici de la classe Card). Les habiletés ont les propriétés suivantes:
    - Un nom
    - Une icône
    - Une valeur entière (optionnelle)
- Il faut pouvoir voir les habiletés d’une carte sur le client
- Il faut faire une animation lorsqu’une habileté est utilisé sur le client. Vous pouvez simplement montrer l’icône de l’habileté avec sa valeur au-dessus de la carte pour un moment.
- Mélanger les cartes dans le CardsPile avant de démarrer une partie pour ne pas toujours commencer avec les mêmes cartes.
- Il y a 3 habiletés (Power) que vous devez ajouter et vous devez en créer 1 autre à votre choix.
    - « First Strike » permet à une carte d’attaquer en « premier » et de ne pas recevoir de dégât si elle tue la carte de l’ennemie. (Fonctionne uniquement à l’attaque, pas à la défense)
    - « Thorns X» lorsqu’une carte défend, elle inflige X de dégâts AVANT de recevoir des dégâts. Si l’attaquant est tué par ces dégâts, l’attaque s’arrête et le défenseur ne reçoit pas de dégâts.
    - « Heal X» soigne les cartes alliées de X incluant elle-même AVANT d’attaquer (mais les cartes ne peuvent pas avoir plus de health qu’au départ.) 
- Note sur les habiletés à votre choix. Pour l’instant, les pouvoirs proposés ne nécessitent pas de garder un « état ». C’est conseillé de choisir des habiletés sans état pour le TP2. Lors du TP3, nous allons exiger des pouvoirs avec un état. Un exemple d’habiletés avec état, c’est « Poison X » qui inflige des dégâts à chaque tour. Dans ce cas, il faut pouvoir ajouter un état « empoisonné » sur CardInstance. (Si vous n’arrivez pas à trouver des idées d’habiletés simples à ajouter, faites signe à votre prof.)

 
## Le détail des sections
### Section d’administration
- L’administrateur peut ajouter et retirer des cartes en ventes au magasin, ainsi que modifier leur prix.
- L’administrateur peut choisir le prix de rachat des cartes (le prix lorsqu’un joueur vend une carte).
- L’administrateur peut modifier les contraintes des « Decks ». Il peut configurer le nombre de « Decks » maximum d’un joueur et le nombre maximum de carte dans chaque « Deck ».
- L’administrateur peut choisir la quantité de monnaie virtuelle du jeu qu’un joueur gagne à chaque partie pour une victoire et pour une défaite.
### Deck
- Un utilisateur doit créer au moins un Deck (paquet de cartes).
- Un deck doit avoir un nom
- Un utilisateur doit choisir quel Deck il apporte dans la partie. Pour la sélection du deck, utiliser la première carte du Deck comme image en plus du nom.
- Seul les cartes du Deck sont disponibles lors d’une partie. (Ce sont les cartes qui vont remplir le CardsPile du match pour ce joueur)
- Une même carte peut faire partie de plusieurs decks.
- Lors du register, un deck qui se nomme "Depart" est créé automatiquement avec toutes les cartes du joueur.
### Magasin
- Les joueurs peuvent acheter et vendre des cartes avec une monnaie virtuelle dans le jeu.
- Les cartes peuvent être achetées et vendues à l’unité.
### Partie
- À chaque partie, un joueur gagne de la monnaie virtuelle du jeu.
    - Une victoire donnera plus de monnaie qu’une défaite.
- Il faut afficher la monnaie virtuelle du joueur dans la barre de menu au haut de l'écran.
- Il faut afficher la monnais gagné dans le menu de victoire/défaite.
	
 
## Contraintes et TDD
- Il y a déjà plusieurs tests unitaires qui vont vous permettre d'être certain que vous avez bien implémenté la logique de votre jeu et les habiletés demandés.
- Les tests existant doivent tous passer avec succès.
- Il faut écrire des tests pour les deux pouvoir au choix et ils doivent également passer avec succès.

- Il faut ajouter des tests unitaires pour certains SERVICES
 
## Tâches individuelles
:::info
Vous devez choisir une des tâches suivantes qui sera évaluer de façon individuelle. Vous devez écrire vous-même le code, mais vous pouvez collaborer avec vos collègues.
:::

:::warning
Vous devez choisir quelque chose de différent du TP1. Donc vous ne pouvez pas reprendre la logique de combat si vous l’aviez déjà fait pour le premier TP, par exemple.
:::

- Écrire les tests pour le combat TDD. Voir la page précédente pour la liste de tous les tests requis.
- Implémenter la logique pour le combat. Il faut faire passer tous les tests et valider que tout fait du sens.
- Achat et vente des cartes Angular.
- Toute la partie MVC.  Achat et vente des cartes et autres configurations (nombre de cartes par deck, nombre de decks, nombre de monnaie virtuelle à la création du compte, après une partie perdue et une partie gagnée.)
- Gestion des decks Angular. Incluant la sélection du deck avant de joindre un match.
- Tous les services. Ajouter les contrôleur, actions et services pour la gestion des decks et la vente et l’achat des cartes.  Avec des tests unitaires.
- Traitement des évènements Angular. ATTENTION : Évitez de prendre cette option si votre jeu n’est pas déjà dans un très bon état après le TP1.


### Achat de paquets de cartes dans le magasin
- Ajouter une rareté aux cartes. Il doit y avoir 4 niveaux:
    - Commune (Gris)
    - Rare (Vert)
    - Épique (Mauve)
    - Légendaire (Orange)
- Ajouter la possibilité de voir et changer la rareté d’une carte en MVC.
- Sur le client, il faut afficher un code de couleur sur les cartes pour pouvoir voir leur rareté. Une option simple c’est de modifier la couleur de fond du titre.
- Ajouter 3 paquets de cartes que les joueurs peuvent acheter. Les cartes sont obtenues au hasard, mais en suivant les règles suivantes.

| Type | Rareté par défaut | Nb Cartes | Règles d’obtention des cartes (sinon c’est la rareté par défaut)
| :--- | :----: | :----: | :----: |
| Basic | Commune | 3 | 30% de rare
| Normal | Commune | 4 | 1 carte rare. Pour le reste : 30% rare, 10% épique, 2% légendaire
| Super	| Rare	| 5	| 1 carte épique. Pour le reste 25% épique, 10% légendaire. (Aucune commune)

- Les paquets ont également un nom, une url d’image et un prix.
- Sur le client, il faut afficher les différents paquets que le joueur peut acheter. 
- Lorsque le joueur en achète un, il faut lui afficher les cartes qu’il vient de recevoir dans un Dialog. Il faut également mettre à jour son argent et ses cartes.
- Le joueur ne peut pas acheter un paquet s’il n’a pas assez d’argent.
- La configuration des paquets et des probabilités doit être fait dans un seed, ce n’est pas nécessaire de pouvoir les modifier en MVC.
 
- Voici le pseudo code pour obtenir une liste de raretés pour notre paquet de carte

```
// Une Probability possède : une value (entre 0 et 1), une rarity et une baseQty
 
// Faire une liste de rareté de carte à obtenir
List<Rarity> GenerateRarities(int nbCards, int defaultRarity, List<Probability> probabilities)
    rarities = new List<Rarity>
 
    // Ajouter la quantité de base pour chaque probability à la liste
    foreach(probability of probabilities)
        for probability.baseQty
            add probability.rarity to rarities
 
    // Continuer de remplir la liste jusqu'à atteindre la quantité voulue
    while(rarities.Count < nbCards)
        rarity = GetRandomRarity(probabilites)
 
        if(rarity == null)
            add defaultRarity to rarities
        else
            add rarity to rarities
 
    return rarities

 
// Cette méthode permet d'obtenir une rareté au hasard
Rarity? GetRandomRarity(List<Probability> probabilities)
    X = Random Number Between 0 and 1
 
    for each rarity of probabilities:
        if probability.value < X:
            return probability.rarity
        else:
            X -= probability.value
 
    return null
```

- Une fois que l’on a une liste de rareté, on peut prendre une carte au hasard avec chacune des raretés pour faire notre paquet. Les doublons sont permis. 