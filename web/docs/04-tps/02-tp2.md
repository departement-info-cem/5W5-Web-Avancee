# TP2 (Suite de Super Cartes Infinies)

## Défis:
- Avoir le même modèle de données (Possible de faire les modifications AVANT)
- GetPowerValue() et HasPower() doivent avoir un stub (par Id de la carte) [Au moins une fois pour chaque power]
- Jouer les animations de power sans partie (l'afficher en cliquant sur les cartes )

## TODO:
- MOI: Obfusquer le code
- FAIRE LES CHANGEMENTS AUX MODELES EN PREMIER (avant de séparer les branches)
- Ajouter un diagramme de classes comme livrable (Avec changement du modèle de données)
- Demander des tests unitaires pour les services
- Gestion des erreurs de cookies
- Parler des sprints
- Montrer des animations de base pour le TP2

## Objectifs : 
Ajouter des fonctionnalités au jeu de cartes développé lors du Sprint 1.

:::info
	Si vous n’avez pas réussi à compléter une partie du TP1, regardez avec votre enseignant pour savoir comment faire le TP2 sans devoir travailler en double.
:::

## Tâches individuelles
:::info
Vous devez choisir une des tâches suivantes qui sera évaluer de façon individuelle. Vous devez écrire vous-même le code, mais vous pouvez collaborer avec vos collègues.
:::

### Résumé
- **\[Obligatoire\]** Ajouter des pouvoirs (Powers)
- **\[Obligatoire\]** Implémenter la logique de jeu
- **\[Obligatoire\]** Ajouter des decks
- Vente et achat de cartes et de paquets

### Ajout des pouvoirs (Powers)
#### Résumé
    - Les cartes peuvent avoir un certains nombres de pouvoirs.
    - Un pouvoir a un nom, une description et un icône.
    - Quand une carte possède un pouvoir, il peut y avoir une valeur entière (Voir les pouvoirs dans les [règles de jeu](#les-règles-de-jeu))
#### Détails
    - Il faut modifier le **modèle** (Ability/AbilityCard)
    - Pouvoir associer les pouvoirs aux cartes (MVC)
    - Logique pour connaitre la valeur d'un pouvoir pour un CardInstance
    - Voir les pouvoirs avec leur valeur sur les cartes sur le client, dans tous les endroits (Mes cartes, magasin, pendant une partie, etc)
    - Pouvoir voir le détails d'une carte avec un appel AJAX
    - Animer les pouvoirs sur le board
    - Ajouter les pouvoirs dans le seed

### Logique de jeu
    - Faire un STUB pour les powers (S'entendre avec la personne qui écrit les Powers)
    - Faire passer les tests de TDD (Voir les [règles de jeu](#les-règles-de-jeu))
    - Il y a déjà plusieurs tests unitaires qui vont vous permettre d'être certain que vous avez bien implémenté la logique de votre jeu et les pouvoirs demandés.
    - Les tests existant doivent tous passer avec succès.
    - Il faut écrire des tests pour le pouvoir au choix et ils doivent également passer avec succès

### Decks
    - Modèle: (Deck/DeckCard)
    - Un deck a un nom
    - Seul les cartes du Deck sont disponibles lors d’une partie. (Ce sont les cartes qui vont remplir le CardsPile du match pour ce joueur)
    - Changer le démarrage d'un Match pour utiliser les cartes du Deck
    - Lors du register, un deck qui se nomme "Depart" est créé automatiquement avec toutes les cartes du joueur.
    - Ajouter la possibilité de créer des decks
    - Une même carte peut faire partie de plusieurs decks.
    - Pouvoir sélectionner le deck actif
    - Tâche MVC: Max de cartes dans un deck et max de nb de decks
    - Ajout d'un service pour la gestion des decks (Tests unitaires)
    - [TODO] Ajouter des détails sur la façon (UI/UX)
    - Utiliser la première carte du Deck comme image en plus du nom

### Rareté et achat/vente de cartes
    - Les joueurs peuvent acheter et vendre des cartes avec une monnaie virtuelle dans le jeu.
    - Modèle: (TradeableCard, Pack et PackRarityStats et Rarity)
    - Monnaie virtuel (gagné dans le jeu Victoire/défaite)
    - Tâche MVC Monnaie virtuel gagné et perdu, par partie
        - nombre de monnaie virtuelle à la création du compte
    - Tâche MVC pour la rareté des cartes
    - Tâche MVC pour le prix des cartes (Achat et Vente)
    - Tâche MVC pour la conception des decks
    - Ajout d'un service pour obtenir les cartes du magasin
    - Ajout d'un service pour l'achat et la vente de cartes (Tests unitaires)
    - Ajout d'un service pour l'achat de paquets (Tests unitaires)
    - Ouverture de paquet
    - Il faut afficher la monnaie virtuelle du joueur dans la barre de menu au haut de l'écran.
    - Il faut afficher la monnais gagné dans le menu de victoire/défaite.
    - [TODO] Ajouter des détails sur la façon (UI/UX)

#### Rareté des cartes
- Ajouter une rareté aux cartes. Il doit y avoir 4 niveaux:
    - Commune (Gris)
    - Rare (Vert)
    - Épique (Mauve)
    - Légendaire (Orange)
- Ajouter la possibilité de voir et changer la rareté d’une carte en MVC.
- Sur le client, il faut afficher un code de couleur sur les cartes pour pouvoir voir leur rareté. Une option simple c’est de modifier la couleur de fond du titre.

#### Achat de paquets de cartes dans le magasin
- Ajouter 3 paquets de cartes que les joueurs peuvent acheter. Les cartes sont obtenues au hasard, mais en suivant les règles suivantes.

| Type | Rareté par défaut | Nb Cartes | Règles d’obtention des cartes (sinon c’est la rareté par défaut)
| :--- | :----: | :----: | :----: |
| Basic | Commune | 3 | 30% de rare
| Normal | Commune | 4 | 1 carte rare. Pour le reste : 30% rare, 10% épique, 2% légendaire
| Super	| Rare	| 5	| 1 carte épique. Pour le reste 25% épique, 10% légendaire. (Aucune commune)

- Les paquets ont également un nom, une url d’image et un prix.
- Sur le client, il faut afficher les différents paquets que le joueur peut acheter. 
- Lorsque le joueur en achète un, il faut lui afficher les cartes qu’il vient de recevoir dans un Dialog. Il faut également mettre à jour son argent et ses cartes.
- Le joueur ne peut pas acheter un paquet s’il n’a pas assez d’argent.
- La configuration des paquets et des probabilités doit être fait dans un seed, ce n’est pas nécessaire de pouvoir les modifier en MVC.
- Voir le [pseudo code](#pseudo-code) pour le contenu des paquets de carte
- Une fois que l’on a une liste de rareté, on peut prendre une carte au hasard avec chacune des raretés pour faire notre paquet. Les doublons sont permis. 
 

### Contraintes
- Le travail doit être effectué en équipes de 3 ou 4.
- Vous devez utiliser **Git/GitHub**.
- Vous devez utiliser **DevOps** pour la gestion des tâches ET utiliser les **sprints**.

### Les étapes
Il y a 2 étapes de livraison du premier TP :
- Diagramme de classe, DevOps et modifications au modèle (évaluation de groupe)
- Fonctionnalités (évaluation individuelle et de groupe en même temps)

### Les règles de jeu
- Mélanger les cartes dans le CardsPile avant de démarrer une partie pour ne pas toujours commencer avec les mêmes cartes.
- Chaque carte prend un tour avec d’être activé (Ce que l’on appelle habituellement le « summoning sickness »).
    - Cependant, elle peut déjà se défendre dès qu’elle est en jeu.
- On peut jouer plusieurs cartes par tour, selon leur coût en « Mana ».
    - Chaque carte à un coût en Mana différent. On peut jouer la carte si le joueur en a assez et après on réduit son mana du coût de la carte.
    - Lorsque le Mana n’est pas utilisé, il s’accumule pour le tour d’après.
    - Lorsqu'un joueur clique sur terminer, les cartes qui sont déjà en jeu doivent être "activé"
- Les pouvoirs des cartes affectent leur façon


#### Pouvoirs
- Il y a 3 pouvoirs (Power) que vous devez ajouter et vous devez en créer 1 autre à votre choix.
    - **First Strike** permet à une carte d’attaquer en « premier » et de ne pas recevoir de dégât si elle tue la carte de l’ennemie. (Fonctionne uniquement à l’attaque, pas à la défense)
    - **Thorns X** lorsqu’une carte défend, elle inflige X de dégâts AVANT de recevoir des dégâts. Si l’attaquant est tué par ces dégâts, l’attaque s’arrête et le défenseur ne reçoit pas de dégâts.
    - **Heal X** soigne les cartes alliées de X incluant elle-même AVANT d’attaquer (mais les cartes ne peuvent pas avoir plus de health qu’au départ.) 
- Note sur les pouvoirs à votre choix. Pour l’instant, les pouvoirs proposés ne nécessitent pas de garder un « état ». C’est conseillé de choisir des pouvoirs sans état pour le TP2. Lors du TP3, nous allons exiger des pouvoirs avec un état. Un exemple de pouvoir avec état, c’est « Poison X » qui inflige des dégâts à chaque tour. Dans ce cas, il faut pouvoir ajouter un état « empoisonné » sur CardInstance. (Si vous n’arrivez pas à trouver des idées de pouvoirs simples à ajouter, faites signe à votre prof.)

### Pseudo code
- Voici le pseudo code pour obtenir une liste de raretés pour notre paquet de carte

<details>
```
// Une Probability possède : une value (entre 0 et 1), une rarity et une baseQty
 
// Faire une liste de rareté de carte à obtenir
List<Rarity> GenerateRarities(int nbCards, int defaultRarity, List<Probability> probabilities)
    rarities = new List<Rarity>
 
    // Ajouter la quantité de base pour chaque probability à la liste
    foreach(probability of probabilities)
        for probability.baseQty
            add probability.rarity to rarities
 
    // Continuer de remplir la liste jusqu'à atteindre la quantité voulue
    while(rarities.Count < nbCards)
        rarity = GetRandomRarity(probabilites)
 
        if(rarity == null)
            add defaultRarity to rarities
        else
            add rarity to rarities
 
    return rarities

 
// Cette méthode permet d'obtenir une rareté au hasard
Rarity? GetRandomRarity(List<Probability> probabilities)
    X = Random Number Between 0 and 1
 
    for each rarity of probabilities:
        if probability.value < X:
            return probability.rarity
        else:
            X -= probability.value
 
    return null
```
</details>
