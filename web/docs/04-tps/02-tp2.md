# TP2 (Suite de Super Cartes Infinies)

## Le projet
Ajouter des fonctionnalit√©s au jeu de cartes d√©velopp√© lors du Sprint 1.

:::info
Vous devez choisir une des t√¢ches suivantes qui sera √©valuer de fa√ßon individuelle. Vous devez √©crire vous-m√™me le code, mais vous pouvez collaborer avec vos coll√®gues.
:::

### Les t√¢ches individuelles
- **\[Obligatoire\]** Ajout des pouvoirs (Powers)
- **\[Obligatoire\]** Logique de jeu
- **\[Obligatoire\]** Ajout des decks
- Raret√© et achat de paquets de cartes

### Contraintes
- Le travail doit √™tre effectu√© en √©quipes de 3 ou 4.
- Vous devez utiliser **Git/GitHub**.
- Vous devez utiliser **DevOps** pour la gestion des t√¢ches ET utiliser les **sprints**.

### Les √©tapes et √©valuations
Il y a 2 √©valuations, mais il est fortement recommand√© de terminer les t√¢ches individuelles au moins une semaine avant la remise d'√©quipe :
- Premier livrable d'√©quipe (Premi√®re √©valuation)
- Fonctionnalit√©s individuelles
- Merge et derni√®re fonctionnalit√© (Deuxi√®me √©valuation)

## Premier livrable d'√©quipe
- Diagramme de classes
- Planification du travail dans Azure DevOps 
- Changements au mod√®le de donn√©es (pour satisfaire √† toutes les t√¢ches individuelles de votre √©quipe)
- Ajout des classes suivantes (entre autres) pour faire l'ajout de powers aux cartes et la logique de jeu

La classe **Power**
```csharp
public class Power
{
    public const int FIRST_STRIKE_ID = 1;
    public const int THORNS_ID = 2;
    public const int HEAL_ID = 3;

    public int Id { get; set; }

    // TODO: √Ä compl√©ter
}
```

La classe **CardPower**
```csharp
public class CardPower
{
    public int Id { get; set; }
    public virtual Card Card { get; set; }
    public virtual Power Power { get; set; }
    public int Value { get; set; }
}
```

Ajouter de cette m√©thode √† la classe **Card**
```csharp
[ValidateNever]
public virtual List<CardPower> CardPowers { get; set; }
```

Ajouter les m√©thodes suivantes √† la classe PlayableCard (Voir le code fournit dans la section "Logique de jeu")
```csharp
public bool HasPower(int powerId)
{
    // Return true if the Card has that power
}
public int GetPowerValue(int powerId)
{
    // Return the value of that power for that card. 
    // Simply returns 0 if the card doesn't have the power.
}
```
- Ajouter des tests unitaires pour v√©rifier que ces nouvelle m√©thodes fonctionnent correctement
    - Un test qui v√©rifie que HasPower retourne false si un **AUTRE power** est pr√©sent sur la carte
    - Un test qui v√©rifie que GetPowerValue retourne 0 si un **AUTRE power** est pr√©sent sur la carte
    - Un test qui v√©rifie que HasPower retourne true si power avec le m√™me Id est pr√©sent sur la carte
    - Un test qui v√©rifie que GetPowerValue retourne la bonne valeur si un power avec le bon Id et une valeur est pr√©sent sur la carte

## T√¢ches individuelles
<details>
    <summary>Ajout des pouvoirs (Powers)</summary>
    - Les cartes peuvent avoir un certains nombres de pouvoirs.
    - Un pouvoir a un nom, une description et un ic√¥ne.
    - Quand une carte poss√®de un pouvoir, il peut y avoir une valeur enti√®re en plus de la relation (Voir les pouvoirs dans les [r√®gles de jeu](#les-r√®gles-de-jeu))
    - Utiliser les Ids de pouvoirs de la classe Power dans votre seed et dans vos MatchEvents
    - Pouvoir associer les pouvoirs aux cartes dans le menu **Edit** (MVC)
        - Voir la liste des pouvoirs d'une carte et pouvoir les retirer un √† un
        - Pouvoir ajouter un nouveau pouvoir avec une valeur enti√®re
    - Voir les pouvoirs avec leur valeur sur les cartes sur le client, dans tous les endroits (Mes cartes, magasin, pendant une partie, etc)
    - Ajouter les pouvoirs dans le seed
    - Animer les pouvoirs en cliquant sur une carte dans Mes Cartes (Afficher l'ic√¥ne du pouvoir sur la carte pendant 2 secondes)
        - Afficher les pouvoirs un apr√®s l'autre si il y en a plusieurs
        - Note: On fait √ßa pour tester les animations et √™tre pr√™t √† les afficher pendant un match
</details>

<details>
    <summary>Logique de jeu</summary>
    - Faire passer les tests de TDD (Voir les [r√®gles de jeu](#les-r√®gles-de-jeu))
    - Pour que les [tests fournis](https://cegepedouardmontpetit.sharepoint.com/:u:/s/CMT420InformatiqueComitesCours-5W5/Ee-3J4x8mxVAl_6JoRJUSDEBV-1q8yiwBC_aaGIDaNwX9Q?e=40i7sT) compilent, il faut avoir d√©j√† ajout√© les classes n√©cessaires et la classe suivante:

L'event **PlayCardEvent**
```csharp
public class PlayCardEvent : MatchEvent
{
    // TODO: Ajouter tout ce qui manque
    public PlayCardEvent(MatchPlayerData currentPlayerData, MatchPlayerData opposingPlayerData, int playableCardId)
    {
    }
}
```
    - Il faut √©crire des tests pour le pouvoir au choix et ils doivent √©galement passer avec succ√®s
    - IMPORTANT: En √©crivant la logique de jeu, il faut utiliser des MatchEvents. Ces MatchsEvents vont √™tre utilis√© pour rejouer les changements sur le client.
    - Il faut donc au moint un MatchEvent pour **chaque pouvoir**, mais √©galement un lorsqu'une carte **attaque, re√ßoit des d√©g√¢ts ou meurt**.
    - Conseil: Ajoutez √©galement un **CardActivationEvent**, ce sera un bon endroit pour g√©rer le combat et v√©rifier les pouvoirs d'une carte et les d√©clencher
    - Conseil: Utilisez les m√©thodes **HasPower** et **GetPowerValue** que vous avez ajout√© √† PlayableCard pour √©crire la logique de jeu.
:::warning
    La gestion des √©v√©nements sur le client est la responsabilit√© de toute l'√©quipe une fois que les parties individuelles ont √©t√© regroup√©es
:::
    - Le diagramme suivant donne une fa√ßon de faire pour g√©rer les events lors d'un combat. Le CardActivationEvent est un bon event pour inclure la logique de plusieurs pouvoirs, comme Heal.

    |![Alt text](image.png)|
    |-|



</details>

<details>
    <summary>Ajout des decks</summary>
    - Un deck a un nom en plus de contenir des cartes (les cartes qu'un joueur poss√®de)
    - Seul les cartes du Deck courant sont disponibles lors d‚Äôune partie. (Ce sont les cartes qui vont remplir le CardsPile du match pour ce joueur)
        - Changer le d√©marrage d'un Match pour utiliser les cartes du deck courrant
    - Lors du register, un deck qui se nomme "Depart" est cr√©√© automatiquement avec toutes les cartes du joueur. (C'est le deck courant du joueur)
    - Une m√™me carte peut faire partie de plusieurs decks. (Les decks sont ind√©pendants les uns des autres)
    - Si j'ai une copie (1 entr√©e OwnedCard) pour une carte, je peux la mettre au maximum une fois dans un deck. Si j'en ai N, je peux en ajouter N.
        - Donc quand j'ajoute une carte √† un deck, je dois proposer √† l'usager **SES** cartes qui ne sont **PAS** d√©j√† dans **CE** deck.
    - Configuration MVC:
        - Nombre max de decks
        - Nombre max de cartes dans un deck
    - Client:
        - Afficher la liste des decks d'un joueur dans une section "Mes Decks"
        - Pouvoir cr√©er un nouveau deck avec un nom au choix (en respectant la limite de decks de la configuration)
        - Pouvoir effacer un deck, si ce n'est pas le deck courant (On ne perd jamais de cartes!)
        - Pouvoir ajouter et retirer une carte √† un deck existant (en respectant la limite de carte de la configuration)
            - Assurez-vous de trier les cartes du joueur pour faciliter la s√©lection
        - Pouvoir rendre un deck courant
        - Doit etre impossible d'effacer le deck courant (v√©rification serveur)
    - Ajouter des tests unitaires pour les nouveaux services
</details>

<details>
    <summary>Achat de paquets de cartes (Pour les √©quipes de 4)</summary>
    
    **R√©sum√©:** Les joueurs peuvent acheter des paquets de cartes (Pack) avec une monnaie virtuelle dans le jeu.
    - Ajouter une raret√© aux cartes. Il doit y avoir 4 niveaux: (Utilis√© un enum)
        - Commune (Gris)
        - Rare (Vert)
        - √âpique (Mauve)
        - L√©gendaire (Orange)
    - Ajouter la possibilit√© de voir et changer la raret√© d‚Äôune carte en MVC.
    - Modifier le seed des cartes avec au moins 2 cartes pour chaque raret√©.
    - Sur le client, il faut afficher un code de couleur sur les cartes pour pouvoir voir leur raret√©. Une option simple c‚Äôest de modifier la couleur de fond du titre.
    - T√¢che MVC de configuration de la monnaie virtuelle:
        - Re√ßue √† la cr√©ation du compte
        - Re√ßue apr√®s une victoire
        - Re√ßue apr√®s une d√©faite (plus petit montant)
    - Sur le client
        - Afficher la monnaie virtuelle du joueur dans la barre de menu au haut de l'√©cran.
        - Afficher la monnaie gagn√© dans le menu de victoire/d√©faite.
        - Afficher les diff√©rents paquets que le joueur peut acheter. 
        - Afficher l'ouverture de paquet sur le client avec un dialogue (qui affiche les cartes re√ßues)
    - Voir la [section sur les paquets de cartes](#d√©tails-sur-les-paquets-de-cartes)
    - Ajouter des tests unitaires pour les nouveaux services
</details>

## Merge et derni√®re √©tape
<details>
    <summary>Travail d'√©quipe</summary>
    - Compl√©ter les t√¢ches individuelles au moins une semaine avant la remise
    - Faire les merge vers votre branche commune

:::warning
    N'oubliez pas de commencer par faire un merge de la branche commune vers votre branche individuelle pour r√©gler les conflits!
:::

    - Ajoutez la gestion des √©v√®nements sur le client dans MatchService.
        - Il faut d√©placer les cartes vers le BattleField lorsqu'elles sont jou√©es
        - Les d√©placer vers le Graveyard lorsqu'elles meurent
        - Faire bouger une carte lorsqu'elle est activ√©e (faire un mouvement qui montre qu'elle est activ√©e)
        - Afficher l'ic√¥ne des pouvoirs sur la carte lorsqu'ils sont activ√©s (pour environ 1 seconde)
        - Mettre √† jour le health des cartes lorsqu'il change
        - Mettre √† jour le health des joueurs lorsqu'il change
</details>

## D√©tails
### Les r√®gles de jeu
<details>
    <summary>D√©tails des r√®gles de jeu</summary>
    - M√©langer les cartes dans le CardsPile avant de d√©marrer une partie pour ne pas toujours commencer avec les m√™mes cartes.
    - On peut jouer plusieurs cartes par tour, selon leur co√ªt en ¬´ Mana ¬ª.
        - Chaque carte √† un co√ªt en Mana diff√©rent.
        - Pendant son tour, un joueur peut jouer une carte si il a assez de mana. On r√©duit ensuite son mana du co√ªt de la carte.
        - Lorsque le Mana n‚Äôest pas utilis√©, il est conserv√© pour le tour d‚Äôapr√®s.
        - Lorsqu'un joueur clique sur terminer, les cartes qui sont d√©j√† en jeu doivent √™tre "activ√©" une apr√®s l'autre pour faire un combat.
    - Lorsqu'une carte est jou√©, elle se place √† la droite des cartes d√©j√† en jeu.
    - Chaque carte a donc son "index", celle qui est le plus √† gauche √† l'index 0, la 2e l'index 1, etc.
    - Lorsqu'une carte est activ√© et qu'il y a une carte devant elle (l'adversaire a une carte avec le m√™me index), les deux cartes se donnent des d√©g√¢ts.
        - Chaque carte perd du health √©gal √† l'attaque de la carte en face d'elle
    - Lorsqu'une carte est activ√© et qu'il n'y a pas de carte devant elle, elle blesse l'adversaire. Le Player adverse perd du health de la valeur de l'attaque.
    - Les pouvoirs des cartes affectent les combats
    - Lorsque les cartes sont activ√©es, il faut commencer par la derni√®re qui a √©t√© jou√© et terminer avec celle qui est en jeu depuis le plus longtemps. On active donc les cartes de droite √† gauche. Ce qui veut √©galement dire que l'on commence par la carte avec l'index le plus √©lev√© et que l'on termine avec l'index 0.

:::waring
Pour l'activation des cartes, c'est plus facile d'utiliser une boucle **for**. Comme c'est possible qu'une carte meurt, la liste de cartes du BattleField risque d'√™tre modifi√© et on ne peut pas modifier la liste pendant une it√©ration avec un **foreach**.
:::
</details>

### Pouvoirs
<details>
    <summary>Les pouvoirs</summary>
    - Il y a 3 pouvoirs (Power) que vous devez ajouter et vous devez en **ajouter 1 autre √† votre choix**.
        - **First Strike** permet √† une carte d‚Äôattaquer en ¬´ premier ¬ª et de ne pas recevoir de d√©g√¢t **si elle tue la carte** de l‚Äôadversaire. (Fonctionne uniquement √† l‚Äôattaque, pas √† la d√©fense)
        - **Thorns X** lorsqu‚Äôune carte d√©fend, elle inflige X de d√©g√¢ts AVANT de recevoir des d√©g√¢ts. Si l‚Äôattaquant est tu√© par ces d√©g√¢ts, l‚Äôattaque s‚Äôarr√™te et le d√©fenseur ne re√ßoit pas de d√©g√¢ts.
        - **Heal X** soigne les cartes alli√©es de X incluant elle-m√™me AVANT d‚Äôattaquer (mais les cartes ne peuvent pas avoir plus de health qu‚Äôau d√©part.) 
    
 :::warning
    - Pour l‚Äôinstant, les pouvoirs propos√©s ne n√©cessitent pas de garder un ¬´ √©tat ¬ª et c‚Äôest conseill√© de **choisir un pouvoir sans √©tat pour le TP2**. Un exemple de pouvoir avec √©tat, c‚Äôest ¬´ Stun ¬ª qui ajoute l'√©tat ¬´ Stunned ¬ª √† une carte. Nous allons ajouter des pouvoir avec √©tat au TP3.
:::
</details>

### D√©tails sur les paquets de cartes
- Ajouter 3 paquets de cartes que les joueurs peuvent acheter. Les cartes sont obtenues au hasard, mais en suivant les r√®gles suivantes.

| Type | Raret√© par d√©faut | Nb Cartes | R√®gles d‚Äôobtention des cartes (sinon c‚Äôest la raret√© par d√©faut)
| :--- | :----: | :----: | :----: |
| Basic | Commune | 3 | 30% de rare
| Normal | Commune | 4 | 1 carte rare. Pour le reste : 30% rare, 10% √©pique, 2% l√©gendaire
| Super	| Rare	| 5	| 1 carte √©pique. Pour le reste 25% √©pique, 10% l√©gendaire. (Aucune commune)

- Les paquets ont un nom, une url d‚Äôimage et un prix.
- La configuration des paquets et des probabilit√©s est faite dans un seed, ce n‚Äôest pas n√©cessaire de pouvoir les modifier en MVC.
- Voir le pseudo code suivant pour vous aider avec la logique d'obtention des cartes

<details>
<summary>Pseudo code pour la raret√© des cartes d'un paquet</summary>
```
// Une Probability poss√®de : une value d√©cimale (entre 0 et 1), une "rarity" et un "baseQty"
 
// Faire une liste de raret√© de carte √† obtenir
List<Rarity> GenerateRarities(int nbCards, int defaultRarity, List<Probability> probabilities)
    rarities = new List<Rarity>
 
    // Ajouter la quantit√© de base pour chaque probability √† la liste
    foreach(probability of probabilities)
        for probability.baseQty
            add probability.rarity to rarities
 
    // Continuer de remplir la liste jusqu'√† atteindre la quantit√© voulue
    while(rarities.Count < nbCards)
        rarity = GetRandomRarity(probabilites)
 
        if(rarity == null)
            add defaultRarity to rarities
        else
            add rarity to rarities
 
    return rarities

 
// Cette m√©thode permet d'obtenir une raret√© au hasard
Rarity? GetRandomRarity(List<Probability> probabilities)
    X = Random Number Between 0 and 1
 
    for each rarity of probabilities:
        if probability.value < X:
            return probability.rarity
        else:
            X -= probability.value
 
    return null
```
Une fois que l‚Äôon a une liste de raret√©, on peut prendre une carte au hasard avec chacune des raret√©s pour faire notre paquet. Les doublons sont permis. 
</details>

## Grille de correction
- 12% de la note pour l‚Äô√©valuation individuelle (voir le document sur la correction individuelle)
- 8% de la note pour l‚Äô√©valuation de groupe
    -	4% pour la premi√®re remise
    -	4% pour la remise final


## R√©f√©rence pour la remise finale en √©quipe

Une r√©f√©rence pour voir un client et un serveur fonctionnels.

- üîó[Client](https://wonderful-coast-01064ff10.5.azurestaticapps.net/)

:::info
Vous pouvez simplement utiliser register pour ajouter vos propres joueurs
:::

- üîó[Serveur](https://supercartesinfiniesTP2.azurewebsites.net/)

:::info
Username: admin@admin.com Le mot de passe: Passw0rd!
:::

:::danger
C'est possible que les exemples ne fonctionnent pas bien selon vos options de cookies. Nous allons les regarder en classe. Pour le truc: [Cookies](/info/Trucs#pour-accepter-les-cookies-third-parties)
:::
